#!/usr/bin/python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2010             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
# 
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
# 
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# ails.  You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.


# targetstate is 1 (used) or 0 (unused)
# info columns: INDEX PHYSTATE OPSTATE TXWORDS RXWORDS
brocade_pystate_names = ['', 'noCard', 'noTransceiver', 'laserFault', 'noLight', 'noSync', 'inSync', 'portFault', 'diagFault', 'lockRef']
brocade_opstate_names = [ 'unknown', 'online', 'offline', 'testing', 'faulty']

fc_brocade_port_detailed_default_levels = ( (1, 0.1), (1, 0.1), (1, 0.1) )

def inventory_brocade_port(checkname, info):
   inventory = []
   for index, phystate, opstate, txwords, rxwords, txframes, rxframes, crcerrors, encout, c3discards in info:
      state = (int(phystate), int(opstate))
      if state == (4,2):
         used = 0
         used_txt = "unused"
      elif phystate == "1" or phystate == "2":
         used = 0
         used_txt = "no card or no transceiver"
      else:
         used = 1
         used_txt = "used"
      # index  is e.g. '3'. But port number printed on switch
      # and in management software of switch counts from 0, so subtract
      # one. Also make it 2-digits => '03'
      if used:
          index = "%02d" % (int(index) - 1)
          inventory.append( (index, used_txt, "fc_brocade_port_detailed_default_levels") )
   return inventory


def check_brocade_port(portno, params, info):

   # SNMP counts ports from 1, but management console and hardware from 0
   portinfo = [ line[1:] for line in info if int(line[0]) == int(portno) + 1 ]
   if len(portinfo) < 1:
      return (3, "UNKNOWN - No port number %d present" % int(portno))
   phystate, opstate, txwords, rxwords, txframes, rxframes, crcerrors, encout, c3discards = map(int, portinfo[0])

   perfdata = [
       ( "txbytes",    "%dc" % (txwords * 4)),
       ( "rxbytes",    "%dc" % (rxwords * 4)),
       ( "crcerrors",  "%dc" % crcerrors ),  # while receiving
       ( "encout",     "%dc" % encout ),     # while transmitting
       ( "c3discards", "%dc" % c3discards ), # 
   ]

   # First check if port has physical and logical link
   state = phystate,opstate
   if state != (6,1):
      return (2, "CRIT - physical state %s, opstate %s" % (brocade_pystate_names[phystate], perfdata))

   # Now check rates of various error counters
   this_time = time.time()
   worst = 0
   texts = []
   try:
       timedif, rxframes_rate = get_counter("fc_brocade_port_detailed.rxframes.%s" % portno, this_time, rxframes)
       timedif, txframes_rate = get_counter("fc_brocade_port_detailed.txframes.%s" % portno, this_time, txframes)
       timedif, rxwords_rate = get_counter("fc_brocade_port_detailed.rxwords.%s" % portno, this_time, rxwords)
       timedif, txwords_rate = get_counter("fc_brocade_port_detailed.txwords.%s" % portno, this_time, txwords)
       texts.append("In: %.1fMB/sec, Out: %.1fMB/sec" % (rxwords_rate / 262144.0, txwords_rate / 262144.0)) # words -> megabytes

       def has_reached_level(level, timedif, per_sec, rate):
	 if type(level) == int: # absolute number 
	    absnumber = timedif * per_sec
	    return absnumber >= level
	 else:
	    return rate * 100.0 >= level


       for descr, counter, value, ref, (warn, crit) in \
	    [ ("CRC errors",  "crcerrors",   crcerrors,  rxframes_rate, params[0] ),
	      ("ENC-Out",     "encout",      encout,     txframes_rate, params[1] ),
	      ("C3 discards", "c3discards",  c3discards, txframes_rate, params[2] ) ]:
	    timedif, per_sec = get_counter("fc_brocade_port_detailed.%s.%s" % (counter, portno), this_time, value)

	    if ref > 0 or per_sec > 0:
	       rate = per_sec / (ref + per_sec)
	    else:
	       rate = 0
	    
	    text = "%s: %d (%.1f%%)" % (descr, timedif * per_sec, rate * 100.0)
	    if has_reached_level(crit, timedif, per_sec, rate):
	       worst = 2
	       text += "!!"
	       texts.append(text)
	    elif has_reached_level(warn, timedif, per_sec, rate):
	       worst = max(worst, 1)
	       text += "!"
	       texts.append(text)

   except MKCounterWrapped:
       # Assume that this is the first check of this port. Make sure, all counters
       # are initialized. If a counter is updated twice, get_counter will handle
       # that correctly.
       for counter, value in [ ("rxwords", rxwords), ("txwords", txwords), ("txframes", txframes, ), 
                               ("crcerrors", crcerrors), ( "encout", encout), ("c3discards", c3discards)]:
	    try:
	       get_counter("fc_brocade_port_detailed.%s.%s" % (counter, portno), this_time, value)
	    except:
	       pass

   if texts == []:
      texts = [ "link status is online/inSync" ]
   infotext  = {0:"OK", 1:"WARN", 2:"CRIT"}[worst] + " - " + ", ".join(texts)
   return (worst, infotext, perfdata)


check_info['fc_brocade_port_detailed'] = (check_brocade_port, "PORT %s", 1,  inventory_brocade_port)
snmp_info['fc_brocade_port_detailed'] = \
   ( "enterprises.1588.2.1.1.1.6.2.1", [ 
    1, # swFCPortIndex 
    3, # swFCPortOpStatus
    4, # swFCPortAdmStatus
   11, # swFCPortTxWords
   12, # swFCPortRxWords
   13, # swFCPortTxFrames
   14, # swFCPortRxFrames
   22, # swFCPortRxCrcs
   26, # swFCPortRxEncOutFrs
   28, # swFCPortC3Discards
   
] )
snmp_scan_functions['fc_brocade_port_detailed'] = \
       lambda oid: oid(".1.3.6.1.2.1.1.2.0") in [ ".1.3.6.1.4.1.1588.2.1.1.1", ".1.3.6.1.4.1.1588.2.1.1.44" ]
