#!/usr/bin/python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2010             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# ails.  You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.


def check_df(mountpoint, params, df_lines):
    # df outputs seven columns:
    # DEVICE FS-TYPE SIZE(KB) USED(KB) AVAIL(KB) USED(%) MOUNTPOINT
    # The mount point may contain spaces (seen on VMWare volumes)

    used_list = [ l for l in df_lines if " ".join(l[6:]).replace('\\','/') == mountpoint ]

    if len(used_list) == 0:
        return (3, "UNKNOWN - %s missing or not a partition" % mountpoint )
    used = used_list[0] # might be listed twice. We take the first occurance

    # In some rare cases the mountpoint may contain a space (happened on ESX).
    if len(used) > 7:
        used = used[0:6] + [ " ".join(used[6:]) ]

    if len(used) != 7 or used[5][-1] != '%':
        return (3, "UNKNOWN - Invalid output from agent (%s)" % (' '.join(used),))

    # Beware: the 6th column of df ("used perc") may includes 5% which are reserved
    # for the superuser, whereas the 4th colum ("used MB") does *not* include that.
    # Beware(2): the column used_mb does not account for the reserved space for
    # superusers. So we rather use the column 'avail' and subtract that from total
    # to compute the used space.

    size_mb   = int(used[2]) / 1024.0
    if size_mb == 0:
        return (1, "WARN - size of filesystem is 0 MB")

    avail_mb   = int(used[4]) / 1024.0
    used_mb = size_mb - avail_mb

    used_perc = 100.0 * (used_mb / size_mb)
    size_gb   = size_mb / 1024.0

    # Get warning and critical levels already with 'magic factor' applied
    warn_mb, crit_mb, levelstext = get_filesystem_levels(g_hostname, mountpoint, size_gb, params)

    # Take into account magic scaling factor (third optional argument
    # in check params). A factor of 1.0 changes nothing. Factor should
    # be > 0 and <= 1. A smaller factor raises levels for big file systems
    # bigger than 100 GB and lowers it for file systems smaller than 100 GB.
    # Please run df_magic_factor.py to understand how it works.

    perfdata = [(mountpoint, str(used_mb) + 'MB', warn_mb, crit_mb, 0, size_mb)]
    infotext = "%.1f%% used (%.1f of %.1f GB), %s" % \
                (used_perc, used_mb / 1024.0, size_gb, levelstext)

    if used_mb >= crit_mb:
        return (2, "CRIT - %s" % infotext, perfdata)
    elif used_mb >= warn_mb:
        return (1, "WARN - %s" % infotext, perfdata)
    else:
        return (0, "OK - %s" % infotext, perfdata)



def inventory_df(checkname, info):
    inventory = []
    for line in info:
        try:
            fs_type    = line[1]
            size_kb = int(line[2])
            if size_kb == 0 or line[5] == '-':
                continue # exclude filesystems without size
            mountpoint = " ".join(line[6:]).replace('\\', '/') # Windows \ is replaced with /

            # exclude some filesystem types and some mountpoints
            if fs_type not in inventory_df_exclude_fs and mountpoint not in inventory_df_exclude_mountpoints:
                inventory.append((mountpoint, None, inventory_df_check_params))
        except ValueError,e:
            sys.stderr.write("Invalid plugin output '%s'\n" % (line,))
            pass # ignore e.g. entries for /proc, etc. if plugin sends any

    return inventory

check_info['df']        = (check_df, "fs_%s", 1, inventory_df)



# New check: df.trend with checks the amount of space
# which has been allocated in a given time range
#
# Author: Lars Michelsen <lm@mathias-kettner.de

df_trend_default_levels = (86400, 1.0, 2.0, 10, None)

# This stores the current value and compares it with the value
# which before "backlog" seconds. If there is no value found
# with this age (check is too new) the oldest known value is used.
def get_trend(itemname, this_time, this_val, backlog):

    # first call: take current value
    if not itemname in g_counters:
        g_counters[itemname] = (this_time, this_val)

        if opt_dont_submit:
            return 0, this_val
        raise MKCounterWrapped(itemname, 'Counter initialization')

    # Get previous value and time difference
    last_time, last_val = g_counters.get(itemname)
    timedif = this_time - last_time

    # Only update when old data is older than 24h
    if this_time - last_time > backlog:
        print "get_trend: Saving new val"
        g_counters[itemname] = (this_time, this_val)

    return timedif, (this_val - last_val)

def inventory_df_trend(checkname, info):
    inventory = []
    for line in info:
        try:
            fs_type    = line[1]
            size_kb = int(line[2])
            if size_kb == 0 or line[5] == '-':
                continue # exclude filesystems without size
            item = " ".join(line[6:]).replace('\\', '/') # Windows \ is replaced with /

            # exclude some filesystem types and some items
            if fs_type not in inventory_df_exclude_fs and item not in inventory_df_exclude_mountpoints:
                inventory.append((item, 'df_trend_default_levels'))
        except ValueError,e:
            sys.stderr.write("Invalid plugin output '%s'\n" % (line,))
            pass # ignore e.g. entries for /proc, etc. if plugin sends any

    return inventory

# FIXME: There is some duplicate code with the df check. Maybe move to include file
def check_df_trend(item, params, info):
    # df outputs seven columns:
    # DEVICE FS-TYPE SIZE(KB) USED(KB) AVAIL(KB) USED(%) MOUNTPOINT
    # The mount point may contain spaces (seen on VMWare volumes)

    used_list = [ l for l in info if " ".join(l[6:]).replace('\\','/') == item ]

    if len(used_list) == 0:
        return (3, "UNKNOWN - %s missing or not a partition" % item )
    used = used_list[0] # might be listed twice. We take the first occurance

    # In some rare cases the item may contain a space (happened on ESX).
    if len(used) > 7:
        used = used[0:6] + [ " ".join(used[6:]) ]

    if len(used) != 7 or used[5][-1] != '%':
        return (3, "UNKNOWN - Invalid output from agent (%s)" % (' '.join(used),))

    bytes_total = saveint(used[2]) * 1024
    bytes_used  = bytes_total - (saveint(used[4]) * 1024)

    # Get trend within the given timerange. When there are no information
    # for the whole range get the oldest available data
    try:
        timedif, trend = get_trend("df.trend.%s" % item, time.time(), saveint(bytes_used), params[0])
    except MKCounterWrapped, e:
        return (3, "UNKNOWN - Initialized value -> Skipping check result")

    # Check thresholds: percentage trend
    perc_used   = 100 * (bytes_used / float(bytes_total))
    perc_trend = 100 * (trend / float(bytes_total))
    status = 0
    status_txt = ''
    if params[2] and perc_trend > params[2]:
        status     = 2
        status_txt = ' (grew more than %s%%)' % params[2]
    elif params[1] and perc_trend > params[1]:
        status     = 1
        status_txt = ' (grew more than %s%%)' % params[1]

    # Format the timedif
    (hours,   seconds) = divmod(timedif, 3600)
    (minutes, seconds) = divmod(seconds,   60)
    timedif_txt = '%02d:%02d:%02d' % (int(hours), int(minutes), int(seconds))

    perfdata = [
      ( 'trend_mb',    '%.2fMB' % (trend / 1024 / 1024), '', '', 0, '%.2f' % (bytes_total / 1024 / 1024)),
      ( 'trend_perc',  '%.2f%%' % perc_trend, params[1], params[2], 0, 100 ),
    ]

    output = "%s trend is %s (%.2f%%) for last %s%s" % \
             (item, get_bytes_human_readable(trend), perc_trend, timedif_txt, status_txt)

    # Calculate the time left, assuming linear growing
    sec_left = -1
    if trend > 0:
        bytes_per_sec = trend / timedif
        sec_left = bytes_total / bytes_per_sec

        if params[4] and params[4] * 86400 > sec_left:
            status     = 2
            status_txt = ' (CRIT: less than %d days left)' % params[4]
        elif params[3] and params[3] * 86400 > sec_left:
            if status < 1:
                status = 1
            status_txt = ' (WARN: less than %d days left)' % params[3]

        # Fortmat the output
        (days,    seconds) = divmod(sec_left, 86400)
        (hours,   seconds) = divmod(seconds,   3600)
        (minutes, seconds) = divmod(seconds,     60)
        output += ' - %d days, %d hours, %d minutes, %d seconds left%s' % \
                       (int(days), int(hours), int(minutes), int(seconds), status_txt)

    perfdata += [('sec_left', sec_left, params[3], params[4])]

    return (status, '%s - %s' % (nagios_state_names[status], output), perfdata)

check_info['df.trend'] = (check_df_trend, "Disk Usage Trend %s", 1, inventory_df_trend)
