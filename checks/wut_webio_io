#!/usr/bin/python

# snmpwalk fehlt

webio_state_names = {
   0 : "Off",
   1 : "On",
}


# Parser for the snmp data, hands back a dict with fugded
# item name and the state of all ports.
def parse_webio_io_inputs(info):
    wut_info = {}
    for line in info:
        input_index, input_desc, state = line
        state = int(state)
        # fix the port index. it is off by one.
        input_index = str(int(input_index) - 1)
        # Do padding with 0, this means we need to handle it as "str"
        # tbh, there is a way in if.include but it is beyond me how that works.
        if len(input_index) < 2:
            input_index  = "0" + input_index 

        if input_desc.startswith("Input"):
            input_desc = input_index
        else:
            input_desc = input_index + " " + input_desc
        wut_info.update({ input_index : (input_desc, state) })

    return wut_info


def inventory_wut_webio_io_inputs(info):
    inventory = []
    wut_info = parse_webio_io_inputs(info)
    # inventorize the err, things.
    for index in wut_info.keys():
        inventory.append((wut_info[index][0], wut_info[index][1]))
    return inventory


def check_wut_webio_io_inputs(item, params, info):
    wut_info = parse_webio_io_inputs(info)
    for index in wut_info.keys():
        descr = wut_info[index][0]
        if wut_info[index][0] == item:
            oldstate = params
            state    = wut_info[index][1]

            # Compare to the last state of the IO port.
            if state != params:
                return (2, "CRITICAL - state should be %s but is %s (!!)" % (
                           webio_state_names[params], 
                           webio_state_names[state]))
            else:
                return (0, "OK - state is %s" % webio_state_names[state])
 

    return (3, "UNKNOWN - Item not found in agent output")


check_info['wut_webio_io.inputs'] = {
    "check_function"     : check_wut_webio_io_inputs,
    "inventory_function" : inventory_wut_webio_io_inputs,
    "service_description": "INPUT %s", 
    "has_perfdata"       : False,
   # "group"              : "",
   # "default_levels_variable" : "services_default_levels",
    # first check we have a vendor mib from W&T, then check for the model in their MIB.
    "snmp_scan_function" : lambda oid:  \
         ".1.3.6.1.4.1.5040" in oid("1.3.6.1.2.1.1.2.0") and 
         oid(".1.3.6.1.4.1.5040.1.2.4.3.3.5.0").lower().startswith("web-io"),
    "snmp_info"          : (".1.3.6.1.4.1.5040.1.2.4", [
         "3.1.5.2.1.1",    # io port index. (bugged)
         "3.2.1.1.1",      # user defined description.
         "1.3.1.4",        # the low/high state.
        ]),
}
