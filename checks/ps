#!/usr/bin/python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2009             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
# 
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
# 
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# ails.  You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.


inventory_processes = []
ANY_USER = None
GRAB_USER = False



def inventory_ps(check_name, info):
    inventory = []
    for servicedesc, pattern, userspec, warnmin, okmin, okmax, warnmax in inventory_processes:
	num_perc_s = servicedesc.count("%s")
	for ps in info:
	    l_user = [userspec]
	    matches = process_matches(ps, pattern, l_user)
	    if matches != False:
		if len(matches) != num_perc_s:
		    raise MKGeneralException("Invalid entry in inventory_processes: service description '%s' contains "
			    "%d times '%%s', but regular expression '%s' contains %d subexpression(s)." % \
			    (servicedesc, num_perc_s, pattern, len(matches)))
		i_servicedesc = servicedesc % matches
		if userspec == GRAB_USER:
		    i_userspec = l_user[0]
		else:
		    i_userspec = ANY_USER
		# Problem here: We need to instantiate all subexpressions
		# with their actual values of the found process.
		i_pattern = instantiate_regex_pattern(pattern, matches)
		inv = ( i_servicedesc, "matched by \"%s\"" % pattern, ( i_pattern, i_userspec, warnmin, okmin, okmax, warnmax ) )
		if inv not in inventory:
		    inventory.append(inv)

    return inventory

def instantiate_regex_pattern(pattern, matches):
    for m in matches:
	pattern = instantiate_regex_pattern_once(pattern, m)
    return pattern

def instantiate_regex_pattern_once(pattern, match):
    # this correctly handles \( and \) but not [^)] - sorry
    return re.compile(r"(?<!\\)\(.*?(?<!\\)\)").sub(escape_regex_chars(match), pattern, 1)

def escape_regex_chars(match):
    r = ""
    for c in match:
	if c in r"[]\().?{}|*^$":
	    r += "\\"
	r += c
    return r


def process_matches(ps, procname, l_user):
    # agent might output username in brackets in the first columns
    userspec = l_user[0]
    if ps[0].startswith("(") and ps[0].endswith(")"):
	user = ps[0][1:-1]
	if userspec and userspec != user:
	    return False
	l_user[0] = user # return actual user that way
	ps = ps[1:]
    else:
	l_user[0] = None

    if not procname:
	return ()

    elif not procname[0].startswith("~"):
	if ps[0] == procname:
	    return ()
    else:
	pattern = procname[1:]
	reg = compiled_regexes.get(pattern)
	if not reg:
	    reg = re.compile(pattern)
	    compiled_regexes[pattern] = reg
	matchobject = reg.match(" ".join(ps))
	if matchobject:
	    return matchobject.groups()
    return False

def check_procs(item, params, info):
    if len(params) == 5:
        procname, warnmin, okmin, okmax, warnmax = params
        user = None
    elif len(params) == 6:
        procname, user, warnmin, okmin, okmax, warnmax = params
    else:
        return (3, "UNKNOWN - invalid check parameters: %s" % (params,))
        
    # procname is either:
    # 1. a string beginning with ~. Then it is interpreted as regular expression
    # that must match the *beginning* of the process line. Please check the output of
    # check_mk -d HOSTNAME. Note: groups of whitespaces are reduced to one single
    # whitespace!
    # 2. a string *not* beginning with ~: It must be equal to the first column
    # in the process table (i.e. the process name). No regular expressions are
    # applied. A simple string compare is done.

    count = 0
    for ps in info:
        if process_matches(ps, procname, [user]) != False:
	    count += 1

    if count > warnmax or count < warnmin:
        return (2, "CRIT - %d processes (ok from %d to %d)" % (count, okmin, okmax))
    elif count > okmax or count < okmin:
        return (1, "WARN - %d processes (ok from %d to %d)" % (count, okmin, okmax))
    else:
        return (0, "OK - %d processes" % count)


check_info['ps'] = (check_procs, "proc_%s", 0,  inventory_ps)
