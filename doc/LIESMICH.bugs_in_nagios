Icinga 1.0.1 mit Livestatus hing nach dem Beenden in futex:

# strace -p 25739
Process 25739 attached - interrupt to quit
futex(0x7fb7f4d399f4, FUTEX_WAIT_PRIVATE, 2, NULL
        
(gdb) bt
#0  0x00007fb7f4abc76e in ?? () from /lib/libc.so.6
#1  0x00007fb7f4a63f3d in ?? () from /lib/libc.so.6
#2  0x00007fb7f4a63cf7 in ?? () from /lib/libc.so.6
#3  0x00000000004408df in get_datetime_string ()
#4  0x0000000000431acc in grab_datetime_macro ()
#5  0x0000000000434085 in grab_macrox_value ()
#6  0x00000000004348b3 in set_macrox_environment_vars ()
#7  0x00000000004348ed in set_all_macro_environment_vars () <=== ***
#8  0x0000000000419313 in run_async_host_check_3x ()
#9  0x000000000041b50f in run_scheduled_host_check_3x ()
#10 0x000000000041b6ba in perform_scheduled_host_check ()
#11 0x000000000042b44b in handle_timed_event ()
#12 0x000000000042b8a1 in event_execution_loop ()
#13 0x0000000000413ef2 in main ()

--> Haenger ist wahrscheinlich abhaengig von dem Setzen
der Umgebungsvariablen.

Im Quellcode von get_datetime_string() sieht man, dass
die Funktion localtime() oder gmtime() verwendet wird.
Beide sind *nicht* threadsafe. Gut möglich, dass die
libc sich hier mit einem futex-schützt. Andere Aufrufe
in die libc gibt es nicht, außer snprintf, der sicherlich
kein Problem machen dürfte. ==> Sieht aus wie ein Bug
in Nagios. Besser, man stellt die Umgebungsvariablen ab.

Haenger von Nagios 3.2.0. Diesmal an dieser Stelle:

#0  0x00fad410 in __kernel_vsyscall ()
#1  0x009acde3 in __lll_lock_wait_private () from /lib/libc.so.6
#2  0x009529eb in _L_lock_1790 () from /lib/libc.so.6
#3  0x00952784 in __tz_convert () from /lib/libc.so.6
#4  0x00950daf in localtime () from /lib/libc.so.6
#5  0x08083636 in get_datetime_string ()
#6  0x08074c9c in grab_datetime_macro ()
#7  0x08077166 in grab_macrox_value ()
#8  0x08077a2c in set_macrox_environment_vars ()
#9  0x08077a61 in set_all_macro_environment_vars () <=== ***
#10 0x08084033 in my_system ()
#11 0x080b5528 in xpddefault_run_service_performance_data_command ()
#12 0x080b55b2 in xpddefault_update_service_performance_data ()
#13 0x080b4f29 in update_service_performance_data ()
#14 0x0805f305 in handle_async_service_check_result ()
#15 0x080603ed in reap_check_results ()
#16 0x0806e3f5 in handle_timed_event ()
#17 0x0806eac7 in event_execution_loop ()
#18 0x080567ac in main ()

In beiden Fällen hängt nicht der Hauptprozess von Nagios im
Lock, sondern ein Sohnprozess. Der Hauptprozess wartet auf
die Beendigung des Sohnprozesses. Die anderen Sohnprozesse sind
Zombies und warten darauf, dass Nagios sie wegwaitet.

*** An dieser Stelle werden alle Umgebungsvariablen gesetzt. Ein Workaround
kann daher sein, die Umgebungsvariablen auszuschalten. Fraglich ist allerdings,
wo das Problem eigentlich herkommt. Welcher Thread bleibt inmitten von localtime()
hängen und gibt das Lock nicht frei? Was ist eigentlich, wenn sich ein Thread
beendet, ohne ein bestimmtes Lock freizugeben? Bleibt das hängen oder wird
es automatisch freigegeben? Und was passiert, wenn ein Prozess geforkt wird,
während ein anderer Thread des Prozesses gerade ein Lock hält? Wird das Lock
vererbt an den neuen Prozess im Zustand "gehalten"? Kann es also sein, dass
wenn Nagios einen Unterprozess abforkt() während gerade ein anderer Thread
localtime() aufruft, dass im Unterprozess das Lock gesperrt ist?

Hier ein Auszug aus der Manpage von pthread_atfork():

   To understand the purpose of pthread_atfork, recall that fork(2) dupli‐
   cates the whole memory space, including mutexes in their current  lock‐
   ing  state,  but only the calling thread: other threads are not running
   in the child process.  The mutexes are not usable after  the  fork  and
   must be initialized with pthread_mutex_init in the child process.  This
   is a limitation of the current implementation and might or might not be
   present in future versions.

Soll das bedeuten, dass man einen Prozess mit Threads nicht mehr forken
kann?



Abgesehen davon ist localtime nicht threadsafe. Da Nagios selbst threads
verwendet, darf es eigentlich localtime nicht verwenden.

Was machen die anderen Threads?
Einer kommt von Nagios:
#0  0x00fad410 in __kernel_vsyscall ()
#1  0x00996973 in poll () from /lib/libc.so.6
#2  0x0807fdf9 in command_file_worker_thread ()
#3  0x00f0749b in start_thread () from /lib/libpthread.so.0
#4  0x009a042e in clone () from /lib/libc.so.6
Der nächste ist der Hauptthread von Livestatus, der auf neue Verbindungen
auf dem Socket wartet. 
Die restlichen Zehn sind die Livestatus-Clientthreads, welche darauf
warten, dass der Hauptthread eine Verbindung in die Queue schmeisst:
#0  0x00fad410 in __kernel_vsyscall ()
#1  0x00f0b595 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0
=> Das sieht alles völlig normal aus.

--> Meine Analyse des Problems:

Nagios macht folgendes, wenn es ein Kommando ausführt (my_system): Es
forkt() sich zunächst einmal. Dann setzt es alle Umgebungsvariablen (wenn
dies in nagios.cfg aktiviert ist). Der Unterprozess startet dann erst
mit popen() den eigentlichen Sohnprozess, liest dessen Ausgabe, wartet
bis er fertig ist und beendet sich dann selbst.

Bei Setzen der Umgebungsvariablen wird - wohl wegen Zeitangaben in den Variablen-
texten - wird localtime() aufgerufen. Innerhalb von localtime() wird ein
Lock verwendet (in glibc eingebaut). Wenn just während des Forkens aber
ein anderer Thread in just diesem Lock steckte (das Lock muss was mit der
Zeitzone zutun haben, weil es von _tz_convert aufgerufen wird), dann erbt
der Sohnprozess das Lock im gelockten Zustand. Die Funktion localtime()
hängt dann für alle Ewigkeit. 

Die Frage ist: Wer hat das Lock belegt? Theoretisch kommt natürlich auch
Livestatus in Frage. Hier müsste man per gdb oder strace mal kontrollieren,
welche Funktion der glibc das gleiche Lock verwendet. Livestatus verwendet
nämlich localtime() nicht. Das Nagios selbst localtime verwendet kann das
Problem hier her kommen. 

Workaround: Environment macros unbedingt abschalten.

