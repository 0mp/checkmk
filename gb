#!/usr/bin/python

import sys, os, time, termios, tty

# colored output, if stdout is a tty
if sys.stdout.isatty():
    tty_red       = '\033[31m'
    tty_green     = '\033[32m'
    tty_yellow    = '\033[33m'
    tty_blue      = '\033[34m'
    tty_magenta   = '\033[35m'
    tty_cyan      = '\033[36m'
    tty_white     = '\033[37m'
    tty_bgred     = '\033[41m'
    tty_bgyellow  = '\033[43m'
    tty_bgblue    = '\033[44m'
    tty_bgmagenta = '\033[45m'
    tty_bgcyan    = '\033[46m'
    tty_bgwhite   = '\033[47m'
    tty_bold      = '\033[1m'
    tty_underline = '\033[4m'
    tty_normal    = '\033[0m'
    def tty_colors(codes):
        return '\033[%sm' % (';'.join([str(c) for c in codes]))
else:
    tty_red       = ''
    tty_green     = ''
    tty_yellow    = ''
    tty_blue      = ''
    tty_magenta   = ''
    tty_cyan      = ''
    tty_white     = ''
    tty_bgblue    = ''
    tty_bgmagenta = ''
    tty_bgcyan    = ''
    tty_bold      = ''
    tty_underline = ''
    tty_normal    = ''
    tty_ok        = 'OK'
    def tty_colors(c):
        return ""

grep_color = tty_bold + tty_green

def bail_out(text):
    sys.stderr.write(text + "\n")
    sys.exit(1)


def goto_bugsdir():
    base_dir = os.path.abspath('.')
    while not os.path.exists(".bugs") and os.path.abspath('.') != '/':
        os.chdir("..")

    try:
        os.chdir(".bugs")
    except:
        sys.stderr.write("Cannot find directory .bugs\n")
        sys.exit(1)

def load_config():
    execfile("config", globals(), globals())

def load_bugs():
    global g_bugs
    g_bugs = {}
    check_modified()
    for entry in os.listdir("."):
        try:
            bugid = int(entry)
            try:
                g_bugs[bugid] = load_bug(bugid)
            except:
                sys.stderr.write("SKIPPING INVALID BUG %d\n" % bugid)
        except:
            continue

def check_modified():
    global g_modified
    g_modified = set([])
    for line in os.popen("git status --porcelain"):
        if line[0] in "AM" and ".bugs/" in line:
            try:
                id = line.rsplit("/", 1)[-1].strip()
                g_modified.add(int(id))
            except:
                pass

def bug_is_modified(bugid):
    return bugid in g_modified


def load_bug(bugid):
    bug = { 
        "id"        : bugid,
        "cost"      : 1,
        "benefit"   : 1,
        "fun"       : 0,
        "state"     : "unknown",
        "title"     : "unknown",
        "component" : "general",
    }
    
    f = file(str(bugid))
    for line in f:
        line = line.strip()
        if line == "":
            break
        header, value = line.split(":", 1)
        bug[header.strip().lower()] = value.strip()

    description = ""
    for line in f:
        description += line

    bug["description"] = description
    return bug

def save_bug(bug):
    f = file(str(bug["id"]), "w")
    f.write("Title: %s\n" % bug["title"])
    for key, val in bug.items():
        if key not in [ "title", "description", "id" ]:
            f.write("%s%s: %s\n" % (key[0].upper(), key[1:], val))
    f.write("\n")
    f.write(bug["description"])
    f.close()
    git_add(bug)

def git_add(bug):
    os.system("git add %d" % bug["id"])


def next_bug_id():
    my_bug_ids = get_bug_ids()
    if not my_bug_ids:
        bail_out('You have no bug ids left. Please reserve additional bug ids.')
    return my_bug_ids[0]


def add_comment(bug, title, comment):
    bug["description"] += """
%s: %s
%s""" % (time.strftime("%F %T"), title, comment)
    


def usage():
    sys.stdout.write("""Usage: gb COMMAND [ARGS...]

where COMMAND is one of:

  ids [#]                - Fetch a bundle of bug ids to be reserved (Default: 10)
  list [-g] [-r] [STATE] - list bugs (-g: sort after gain, -r: reverse)
  new                    - create a new bug
  show [# #..]           - show several bugs (or all open)
  resolve ID             - change a bugs state
  delete #..             - delete bug(s)
  grep [-v] WHAT...      - grep in titles and descriptions (-v: verbose)
  edit [#]               - open bug # in editor (or newest bug)
  commit                 - commit all changed and new bugs

""")
    sys.exit(1)

def bug_state(bug):
    state = bug["state"]
    return "%s%-7s%s" % (tty_bold + states.get(state, ""), state, tty_normal)

def num_color(n, colors, inverse):
    if inverse:
        b = 40
    else:
        b = 30

    c = colors[n-1]
    return tty_colors([b + c, 1])

def bug_gain(bug):
    cost    = int(bug["cost"])
    benefit = int(bug["benefit"])
    gain = benefit - cost
    if gain >= 2:
        color = 2
    elif gain > 0:
        color = 6
    elif gain <= -3:
        color = 1
    elif gain <= -2:
        color = 5
    elif gain < 0:
        color = 3
    else:
        color = 4
    return "%s%d%s%d%s" % (
            tty_colors([40 + color, 1]), cost, tty_colors([0, 30 + color, 1]), benefit, tty_normal)

def list_bug(bug):
    if bug_is_modified(bug["id"]):
        bold = tty_bold + tty_cyan + "(*) "
    else:
        bold = ""
    sys.stdout.write("#%04d %s %-6s %-9s %-10s %s%-60s%s\n" %
            (int(bug["id"]),
             bug_gain(bug), bug_state(bug), 
             bug["class"], bug["component"], bold, bug["title"], tty_normal))

def show_bug(bug):
    list_bug(bug)
    sys.stdout.write("\n%s\n" % bug["description"])

def main_list(args):
    bugs = g_bugs.values()

    # arguments are tags from state, component and class. Multiple values
    # in one class are orred. Multiple types are anded.
    filters = {}
    def cmp_gain(a, b):
        ga = int(a["benefit"]) - int(a["cost"])
        gb = int(b["benefit"]) - int(b["cost"])
        return ga - gb

    sort = None
    reverse = False
    for a in args:
        if a == '-g':
            sort = cmp_gain
            continue

        if a == '-r':
            reverse = True
            continue

        hit = False
        for tp, values in [
          ( "component", components ), ( "state", states ), ( "class", classes ),  ]:
            for v in values:
                if v.startswith(a):
                    entries = filters.get(tp, [])
                    entries.append(v)
                    filters[tp] = entries
                    hit = True
                    break
            if hit:
                break
        if not hit:
            bail_out("No such component, state or class: %s" % a)

    # Filter
    newbugs = []
    for bug in bugs:
        skip = False
        for tp, entries in filters.items():
            if bug[tp] not in entries:
                skip = True
                break
        if not skip:
            newbugs.append(bug)
    bugs = newbugs
            
    # Sort
    if sort:
        newbugs.sort(sort)
    if reverse:
        newbugs.reverse()

    # Output
    for bug in bugs:
        list_bug(bug)


def main_show(args):
    ids = args
    if len(ids) == 0:
        ids = [ id for (id, bug) in g_bugs.items() if bug["state"] == "open" ]
    for id in ids:
        if id != ids[0]:
            sys.stdout.write("-------------------------------------------------------------------------------\n")
        show_bug(g_bugs[int(id)])

def get_input(what, default = ""):
    sys.stdout.write("%s: " % what)
    sys.stdout.flush()
    value = sys.stdin.readline().strip()
    if value == "":
        return default
    else:
        return value
    
def get_long_input(what):
    sys.stdout.write("Enter %s. End with CTRL-D.\n" % what)
    usertext = sys.stdin.read()
    # remove leading and trailing empty lines
    while usertext.startswith("\n"):
        usertext = usertext[1:]
    while usertext.endswith("\n\n"):
        usertext = usertext[:-1]
    return usertext

def getch():
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    if ord(ch) == 3:
        raise KeyboardInterrupt()
    return ch

def input_choice(what, choices):
    ctc = {}
    texts = []
    for choice in choices:
        for c in choice:
            if c not in ctc:
                ctc[c] = choice
                texts.append(choice.replace(c, tty_bold + c + tty_normal, 1))
                break
    
    while True:
        sys.stdout.write("%s (%s): " % (what, ", ".join(texts)))
        sys.stdout.flush()
        c = getch()
        if c in ctc:
            sys.stdout.write(" %s%s%s\n" % (
                        tty_bold, ctc[c], tty_normal))
            return ctc[c]
        else:
            sys.stdout.write("\n")

def main_new(args):
    bug = {}
    bug["id"]      = next_bug_id()
    bug["state"]   = "open"
    bug["date"]    = time.strftime("%F %T")
    bug["title"]   = get_input("Title")
    if  bug["title"] == "":
        sys.stderr.write("Cancelled.\n")
        sys.exit(0)
    bug["class"]     = input_choice("Class",     classes)
    bug["component"] = input_choice("Component", components)
    bug["cost"]      = input_choice("Cost",      "123456789")
    bug["benefit"]   = input_choice("Benefit",   "123456789")
    
    bug["description"] = get_long_input("description")
    g_bugs[bug["id"]] = bug
    save_bug(bug)
    invalidate_my_bugid(bug["id"])
    sys.stdout.write("Bug saved with id %d.\n" % bug["id"])

def main_resolve(args):
    if len(args) != 1:
        usage()
    id = int(args[0])
    bug = g_bugs.get(id)
    if not bug:
        bail_out("No such bug.\n")

    list_bug(bug)
    state = input_choice("State", states.keys())

    comment = get_long_input("comment")
    add_comment(bug, "changed state %s -> %s" % (bug["state"], state), comment)
    bug["state"] = state
    save_bug(bug)

def main_delete(args):
    for ids in args:
        if 0 == os.system("git rm %s" % ids):
            sys.stdout.write("Delete bug %s (%s)\n" % (ids, g_bugs[int(ids)]["descriptions"]))

def grep(line, kw):
    lc = kw.lower()
    i = line.lower().find(lc)
    if i == -1:
        return None
    else:
        return line[0:i] + grep_color + line[i:i+len(kw)] + tty_normal + line[i+len(kw):]
    

def main_grep(args):
    if '-v' in args:
        verbose = True
        args = [ a for a in args if a != '-v' ]
    else:
        verbose = False

    if len(args) == 0:
        usage()

    for bug in g_bugs.values():
        didmatch = False
        for kw in args:
            match = grep(bug["title"], kw)
            if match:
                bug["title"] = match
                didmatch = True
            lines = bug["description"].split("\n")
            bodylines = ""
            for line in lines:
                match = grep(line, kw)
                if match:
                    bodylines += "  " + match + "\n"
                    didmatch = True
        if didmatch:
            list_bug(bug)
            if verbose:
                sys.stdout.write(bodylines)

def main_edit(args):
    if len(args) == 0:
        ids = str(max(g_bugs.keys()))
    else:
        ids = args[0] 
    if not os.path.exists(ids):
        bail_out("No bug with this id.")
    editor = os.getenv("EDITOR")
    if not editor:
        for p in [ "/usr/bin/editor", "/usr/bin/vim", "/bin/vi" ]:
            if os.path.exists(p):
                editor = p
                break
    if not editor:
        bail_out("No editor available (please set EDITOR).\n")

    if 0 == os.system("%s %s" % (editor, ids)):
        git_add(g_bugs[int(ids)])


def main_commit(args):
    if len(g_modified) == 0:
        bail_out("No new or modified bug.")
    else:
        sys.stdout.write("Commiting:\n")
        for id in g_modified:
            list_bug(g_bugs[id])
        if 0 == os.system("git commit -m 'Updated bug entries' ."):
            sys.stdout.write("--> Successfully committed %d bugs.\n" % len(g_modified))
        else:
            bail_out("Cannot commit.")


def get_bug_ids():
    try:
        return eval(file('.my_ids', 'r').read())
    except:
        return []


def invalidate_my_bugid(id):
    ids = get_bug_ids()
    ids.remove(id)
    store_bug_ids(ids)


def store_bug_ids(l):
    file('.my_ids', 'w').write(repr(l))


def main_fetch_ids(args):
    if not args:
        num = 10
    elif len(args) == 1:
        num = int(args[0])
    else:
        usage()

    # Get the start bug_id to reserve
    try:
        first_free = int(eval(file('first_free').read()))
    except:
        first_free = 0
    new_first_free = first_free + num

    # Store the bug_ids to reserve
    my_ids = get_bug_ids() + range(first_free, first_free + num)
    store_bug_ids(my_ids)

    # Store the new reserved bug ids
    file('first_free', 'w').write(str(new_first_free))

    sys.stdout.write('Reserved %d additional IDs now. You have %d reserved IDs now.\n' %
                                                                      (num, len(my_ids)))

    if 0 == os.system("git commit -m 'Reserved %d bug ids' ." % num):
        sys.stdout.write("--> Successfully committed reserved bug ids. Please push it soon!\n")
    else:
        bail_out("Cannot commit.")


#                    _       
#    _ __ ___   __ _(_)_ __  
#   | '_ ` _ \ / _` | | '_ \ 
#   | | | | | | (_| | | | | |
#   |_| |_| |_|\__,_|_|_| |_|
#                            

goto_bugsdir()
load_config()
load_bugs()

if len(sys.argv) < 2:
    usage()

cmd = sys.argv[1]
commands = {
  "list"    : main_list,
  "show"    : main_show,
  "new"     : main_new,
  "resolve" : main_resolve,
  "delete"  : main_delete,
  "grep"    : main_grep,
  "edit"    : main_edit,
  "commit"  : main_commit,
  "ids"     : main_fetch_ids,
}

hits = [] 
for name, func in commands.items():
    if name == cmd:
        hits = [ (name, func) ]
        break
    elif name.startswith(cmd):
        hits.append((name, func))

if len(hits) < 1:
    usage()

elif len(hits) > 1:
    sys.stderr.write("Command '%s' is ambigous. Possible are: %s\n" % \
            ", ".join([ n for (n,f) in hits]))

else:
    hits[0][1](sys.argv[2:])

