#!/usr/bin/python

import sys, os, time, termios, tty

# colored output, if stdout is a tty
if sys.stdout.isatty():
    tty_red       = '\033[31m'
    tty_green     = '\033[32m'
    tty_yellow    = '\033[33m'
    tty_blue      = '\033[34m'
    tty_magenta   = '\033[35m'
    tty_cyan      = '\033[36m'
    tty_white     = '\033[37m'
    tty_bgred     = '\033[41m'
    tty_bgyellow  = '\033[43m'
    tty_bgblue    = '\033[44m'
    tty_bgmagenta = '\033[45m'
    tty_bgwhite   = '\033[47m'
    tty_bold      = '\033[1m'
    tty_underline = '\033[4m'
    tty_normal    = '\033[0m'
else:
    tty_red       = ''
    tty_green     = ''
    tty_yellow    = ''
    tty_blue      = ''
    tty_magenta   = ''
    tty_cyan      = ''
    tty_white     = ''
    tty_bgblue    = ''
    tty_bgmagenta = ''
    tty_bold      = ''
    tty_underline = ''
    tty_normal    = ''
    tty_ok        = 'OK'

grep_color = tty_bold + tty_green

def bail_out(text):
    sys.stderr.write(text + "\n")
    sys.exit(1)


def goto_bugsdir():
    base_dir = os.path.abspath('.')
    while not os.path.exists(".bugs") and os.path.abspath('.') != '/':
        os.chdir("..")

    try:
        os.chdir(".bugs")
    except:
        sys.stderr.write("Cannot find directory .bugs\n")
        sys.exit(1)

def load_config():
    execfile("config", globals(), globals())

def load_bugs():
    global g_bugs
    g_bugs = {}
    for entry in os.listdir("."):
        try:
            bugid = int(entry)
            try:
                g_bugs[bugid] = load_bug(bugid)
            except:
                sys.stderr.write("SKIPPING INVALID BUG %d\n" % bugid)
        except:
            continue


def load_bug(bugid):
    bug = { 
        "id"        : bugid,
        "cost"      : 1,
        "benefit"   : 1,
        "fun"       : 0,
        "state"     : "unknown",
        "title"     : "unknown",
        "component" : "general",
    }
    
    f = file(str(bugid))
    for line in f:
        line = line.strip()
        if line == "":
            break
        header, value = line.split(":", 1)
        bug[header.strip().lower()] = value.strip()

    description = ""
    for line in f:
        description += line

    bug["description"] = description
    return bug

def save_bug(bug):
    f = file(str(bug["id"]), "w")
    f.write("Title: %s\n" % bug["title"])
    for key, val in bug.items():
        if key not in [ "title", "description", "id" ]:
            f.write("%s%s: %s\n" % (key[0].upper(), key[1:], val))
    f.write("\n")
    f.write(bug["description"])
    f.close()
    git_add(bug)

def git_add(bug):
    os.system("git add %d" % bug["id"])

def next_bug_id():
    if len(g_bugs) == 0:
        return 1
    else:
        return max(g_bugs.keys()) + 1

def add_comment(bug, title, comment):
    bug["description"] += """
%s: %s
%s""" % (time.strftime("%F %T"), title, comment)
    


def usage():
    sys.stdout.write("""Usage: gb COMMAND [ARGS...]

where COMMAND is one of:

  list [STATE]   - list bugs
  new            - create a new bug
  show [# #..]   - show several bugs (or all open)
  resolve ID     - change a bugs state
  delete #..     - delete bug(s)
  grep WHAT...   - grep in titles and descriptions
  edit [#]       - open bug # in editor (or newest bug)

""")
    sys.exit(1)

def bug_state(bug):
    state = bug["state"]
    return "%s%-7s%s" % (tty_bold + states.get(state, ""), state, tty_normal)

def list_bug(bug):
    sys.stdout.write("%s#%04d%s %-6s %-9s %-10s %-60s\n" %
            (tty_bold, int(bug["id"]), tty_normal, bug_state(bug), 
             bug["class"], bug["component"], bug["title"]))

def show_bug(bug):
    list_bug(bug)
    sys.stdout.write("\n%s\n" % bug["description"])

def main_list(args):
    bugs = g_bugs.values()
    # arguments are tags from state, component and class. Multiple values
    # in one class are orred. Multiple types are anded.
    filters = {}
    for a in args:
        hit = False
        for tp, values in [
          ( "component", components ), ( "state", states ), ( "class", classes ),  ]:
            for v in values:
                if v.startswith(a):
                    entries = filters.get(tp, [])
                    entries.append(v)
                    filters[tp] = entries
                    hit = True
                    break
            if hit:
                break
        if not hit:
            bail_out("No such component, state or class: %s" % a)

    # sort
    for bug in bugs:
        skip = False
        for tp, entries in filters.items():
            if bug[tp] not in entries:
                skip = True
                break
        if not skip:
            list_bug(bug)


def main_show(args):
    ids = args
    if len(ids) == 0:
        ids = [ id for (id, bug) in g_bugs.items() if bug["state"] == "open" ]
    for id in ids:
        if id != ids[0]:
            sys.stdout.write("-------------------------------------------------------------------------------\n")
        show_bug(g_bugs[int(id)])

def get_input(what, default = ""):
    sys.stdout.write("%s: " % what)
    sys.stdout.flush()
    value = sys.stdin.readline().strip()
    if value == "":
        return default
    else:
        return value
    
def get_long_input(what):
    sys.stdout.write("Enter %s. End with CTRL-D.\n" % what)
    usertext = sys.stdin.read()
    # remove leading and trailing empty lines
    while usertext.startswith("\n"):
        usertext = usertext[1:]
    while usertext.endswith("\n\n"):
        usertext = usertext[:-1]
    return usertext

def getch():
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    if ord(ch) == 3:
        raise KeyboardInterrupt()
    return ch

def input_choice(what, choices):
    ctc = {}
    texts = []
    for choice in choices:
        for c in choice:
            if c not in ctc:
                ctc[c] = choice
                texts.append(choice.replace(c, tty_bold + c + tty_normal, 1))
                break
    
    while True:
        sys.stdout.write("%s (%s): " % (what, ", ".join(texts)))
        sys.stdout.flush()
        c = getch()
        if c in ctc:
            sys.stdout.write(" %s%s%s\n" % (
                        tty_bold, ctc[c], tty_normal))
            return ctc[c]
        else:
            sys.stdout.write("\n")

def main_new(args):
    bug = {}
    bug["id"]      = next_bug_id()
    bug["state"]   = "open"
    bug["date"]    = time.strftime("%F %T")
    bug["title"]   = get_input("Title")
    if  bug["title"] == "":
        sys.stderr.write("Cancelled.\n")
        sys.exit(0)
    bug["class"]     = input_choice("Class",     classes)
    bug["component"] = input_choice("Component", components)
    bug["cost"]      = input_choice("Cost",      "123456789")
    bug["benefit"]   = input_choice("Benefit",   "123456789")
    
    bug["description"] = get_long_input("description")
    g_bugs[bug["id"]] = bug
    save_bug(bug)
    sys.stdout.write("Bug saved with id %d.\n" % bug["id"])

def main_resolve(args):
    if len(args) != 1:
        usage()
    id = int(args[0])
    bug = g_bugs.get(id)
    if not bug:
        bail_out("No such bug.\n")

    list_bug(bug)
    state = input_choice("State", states.keys())

    comment = get_long_input("comment")
    add_comment(bug, "changed state %s -> %s" % (bug["state"], state), comment)
    bug["state"] = state
    save_bug(bug)

def main_delete(args):
    for ids in args:
        if 0 == os.system("git rm %s" % ids):
            sys.stdout.write("Delete bug %s (%s)\n" % (ids, g_bugs[int(ids)]["descriptions"]))

def grep(line, kw):
    lc = kw.lower()
    i = line.lower().find(lc)
    if i == -1:
        return None
    else:
        return line[0:i] + grep_color + line[i:i+len(kw)] + tty_normal + line[i+len(kw):]
    

def main_grep(args):
    if len(args) == 0:
        usage()
    for bug in g_bugs.values():
        didmatch = False
        for kw in args:
            match = grep(bug["title"], kw)
            if match:
                bug["title"] = match
            lines = bug["description"].split("\n")
            bodylines = ""
            for line in lines:
                match = grep(line, kw)
                if match:
                    bodylines += "  " + match + "\n"
                    didmatch = True
        if didmatch:
            list_bug(bug)
            sys.stdout.write(bodylines)

def main_edit(args):
    if len(args) == 0:
        ids = str(max(g_bugs.keys()))
    else:
        ids = args[0] 
    if not os.path.exists(ids):
        bail_out("No bug with this id.")
    editor = os.getenv("EDITOR")
    if not editor:
        for p in [ "/usr/bin/editor", "/usr/bin/vim", "/bin/vi" ]:
            if os.path.exists(p):
                editor = p
                break
    if not editor:
        bail_out("No editor available (please set EDITOR).\n")

    if 0 == os.system("%s %s" % (editor, ids)):
        git_add(g_bugs[int(ids)])


#                    _       
#    _ __ ___   __ _(_)_ __  
#   | '_ ` _ \ / _` | | '_ \ 
#   | | | | | | (_| | | | | |
#   |_| |_| |_|\__,_|_|_| |_|
#                            

goto_bugsdir()
load_config()
load_bugs()

if len(sys.argv) < 2:
    usage()

cmd = sys.argv[1]
commands = {
  "list"    : main_list,
  "show"    : main_show,
  "new"     : main_new,
  "resolve" : main_resolve,
  "delete"  : main_delete,
  "grep"    : main_grep,
  "edit"    : main_edit,
}

hits = [] 
for name, func in commands.items():
    if name == cmd:
        hits = [ (name, func) ]
        break
    elif name.startswith(cmd):
        hits.append((name, func))

if len(hits) < 1:
    usage()

elif len(hits) > 1:
    sys.stderr.write("Command '%s' is ambigous. Possible are: %s\n" % \
            ", ".join([ n for (n,f) in hits]))

else:
    hits[0][1](sys.argv[2:])

