title: McData FibreChannel Switches: Traffic and Status of Ports
agents: snmp
catalog: hw/storagehw/mcdata
license: GPL
distribution: check_mk
description:
 This check monitors the operational status, link speed, traffic, frame
 counts, C3 discards and CRC errors of FibreChannel port of McData FC switches.

 This check uses the internal logic of the {if}/{if64} check, so at some places
 the naming conventions are a bit unusual (instead of frames, the check speaks
 of packages, for example). The advantage of this approach is, on the other
 hand, that this check makes use of all interesting features if {if}, such
 as averaging, nice PNP templates, Perf-O-Meters and other stuff.

 Depending on the check parameters this check can go WARN or CRIT when the
 port status changes (i.e. is down), when the link speed changes (e.g. a
 port expected to be set to 2GBit/s operates only at 1GBit/s), when the
 absolute or procentual traffic of a port exceeds certain levels or if the
 rate of errors or discards exceeds configurable limits.

 This check supports averaging the in- and outgoing traffic over a configurable
 range of time by using an exponentially weighted moving average - just as
 Linux does for the CPU load averages.  The averaging can be configured on
 a per host and per port base. This is done by adding a key {"average"}
 to the parameter dictionary with the number of minutes that the average
 should cover as its key. Port with averaging turned on output two additional
 performance values: the averaged traffic in bytes. If you have configured
 traffic levels, then those levels are applied to the averaged values.

item:
 The port index as two digit string, for example {"03"} or {"24"}. The first
 port has the number {"01"}.

inventory:
 The inventory creates one service for each port that fulfills configurable conditions.
 Per default these are ports which are currently found {up} and are of types {6} (ethernetCsmacd),
 {32} (frameRelay) or {117} (gigabitEthernet). This check announces the port
 type of {6} for the FC ports. This is not exactly correct but makes the inventory
 find the FC ports without further configuration.

 {Grouping:} In some situations you do not want to monitor a single
 interface but a group of interfaces that together form a pool.
 The {if} check supports such pools by defining groups.
 You can specifiy the members of a group by their port type and the item name(s) of
 the single interfaces. The data of all members is accumulated and put together
 in a single grouped interface service.

 You can specify the groups with the ruleset {if_groups}.
 Groups are defined as list of dictionaries.

 The keys are:

  {"name"}:   String. Name of the group within the service description

  {"iftype"}: Integer. Interface port type as integer

  {"include_items"}: List of Strings. Interface item name. This name depends
  on further settings like if_inventory_uses_alias or if_inventory_uses_description

  {"single"}(optional): Bool. Interfaces in this group do not show up
  as single service if "single" is set to True (Default: False)

  For example: if_groups = ([{"name" : "Group WLAN", "iftype" : 6, "single" : True}], ["lan"], ALL_HOSTS )

examples:
 Definition for grouped interfaces
 if_groups = [
   ( [{"name" : "VLAN", "iftype" : 53, "single" : True },
      {"name" : "voiceDID", "iftype" : 213}], [], ALL_HOSTS ),
   ( [{ "name" : "Group WLAN", "iftype" : 6, "single" : True }], [ "lan" ], ALL_HOSTS )
 ]

perfdata:
 {in}: The number of bytes received per second.
 {inucast}: The number of unicast packets received per second.
 {innucast}: The number of broadcast and multicast packets per second.
 {indisc}: The number of discarded received packets per second.
 {inerr}: The number of input errors per second.
 {out}: The number of bytes sent per second.
 {outucast}: The number of unicast packets sent per second.
 {outnucast}: The number of broadcast and multicast packets sent per second.
 {outdisc}: The number of output packets discarded per second.
 {outerr}: The number of output errors per second.
 {outqlen}: The current length of the output queue.
 {in_avg_?}: optional: The averaged number of received bytes over a longer range of time
 {out_avg_?}: optional: The averaged number of sent bytes

[parameters]
parameters (dict): Due to its complexity, this check now uses a dictionary as
                   parameter. The tuple representation used up to version 1.1.8 are
                   currently still supported but discouraged. The dictionary can have
                   the following keys:

                   {"errors"} - a pair of two float values to be used as WARN/CRIT
                   percentages for errors + discards. The default is {(0.01, 0.1)} - which
                   means that the services gets WARN if the error rate is at least
                   0.01 percent. That means that one error per 10,000 packages is seen.

                   {"traffic"} - a pair of two float values to be used as WARN/CRIT
                   levels for the bandwidth usage of the port. Integer numbers are interpreted
                   as bytes per seconds. So a value of {(500,1000)} will trigger WARN/CRIT
                   if either the ingoing or outgoing traffic exceeds 500/1000 bytes per second.
                   If you use floating point number, those are interpreted as percentages
                   of the available bandwidth as signalled by the port. A value of {(50.0, 80.0)}
                   will trigger WARN/CRIT, if at least 50%/80% of the nominal bandwidth is
                   used. The default is to impose no levels on the traffic.

                   {"average"} - if you set this key to a number, then it is interpreted as
                   a time in minutes. The check will then compute the averaged used traffic
                   over approximately that range of time. Note: The algorithm used here is
                   the same as Linux uses for the CPU load. This means that more recent values
                   are weighted higher than older values and that even values out of the configured
                   time range are - to a low degree - represented in the average. If you configure
                   an average, then the traffic levels are applied to the averaged values.

                   {"state"} - the expected operational status of the interface (as string or list of strings. If this
                   is {None} then the state is not checked. Possible values for the
                   state are {"1"}(up), {"2"}(down), {"3"}(testing), {"4"}(unknown),
                   {"5"}(dormant), {"6"}(notPresent) and {"7"}(lowerLayerDown). The default is to
                   remember the state found during inventory and enforce this. It is allowed to
                   set {"state"} either to a string (one single allowed state) or a list of
                   strings. For example set this to '{["1", "5"]}' if you want to allow {up}
                   and {dormant}.

                   {"speed"} - the expected port speed as an integer of the bits per second (not
                   the bytes!). If you set this to {None}, then the port speed is not checked.
                   The default is to remember and enforce the port speed found during inventory.

                   {"assumed_speed_in"} - the assumed port input speed as an integer of the bits per second (not
                   the bytes!). If this value is not set the check takes the value configured in {speed}
                   before using the automatically detected port speed

                   {"assumed_speed_out"} - the assumed port output speed as an integer of the bits per second (not
                   the bytes!). If this value is not set the check takes the value configured in {speed}
                   before using the automatically detected port speed

