--------------------------------------------------------------------------------
INS RELEASE 1.2
--------------------------------------------------------------------------------
check_mk -X erzwingen. Das -R soll nur noch klappen, wenn kein Configfehler
auftritt.

direct rrd-updates deprecaten oder rausnehmen. Diese sorgen dafür, dass
die Perf-O-Meter und die PNP-Suche in Multisite nicht geht.

filesystem_levels rausnehmen. Hinweis, dass check_parameters verwendet werden
soll.

--------------------------------------------------------------------------------
BUGS beheben bis => 1.1.7i5
--------------------------------------------------------------------------------
Beschreibung zu -II fehlt in Doku.


--------------------------------------------------------------------------------
BUGS beheben bis => 1.1.8
--------------------------------------------------------------------------------
habe da wohl noch einen zweiten Bug im Multisite gefunden.
Der erste war ja, wie bereits geschrieben: Wenn Umlaut in Hostgroup Alias vorkommt,
funktioniert nichts mehr, was irgendwie diese Aliases ausliest. Wird wohl auch an anderer Stelle sein,
bei der Multisite mit Umlauten arbeiten muss.

Noch eine Kleinigkeit im Mulisite, ist zwar kein Bug: in der Host View, in der
man alle Services zu einem Host sieht, fehlt der Host.  Beispiel: Nagvis ist
ein Host rot, man klickt ihn an, landet in Multisite, und sieht lauter Grüne
Dienste (bis auf Check_mk, der ist Gelb und hat "null" im Text stehen. Jetzt
muss man erst noch Host Status anklicken, um zu sehen, der ist Down.  Sprich,
in der view Host fehlt jeder Hinweis auf ein Fehler auf dem Host.

Multisite: noch nicht alle Dateien werden mit den richtigen Rechten angelegt:
Das hier kommt aus config: Dazu gibt es in lib eine Funktion, die man nehmne
sollte!
def save_user_file(name, content):
        path = user_confdir + "/" + name + ".mk"
            try:
                file(path, "w").write(pprint.pformat(content) + "\n")
            except Exception, e:
                raise MKConfigError("Cannot save %s options for user <b>%s</b> into <b>%s</b>: %s" % \
                                        (name, user, path, e))

Doku Livestatus: group_authorization nicht gesetzt, hat aber Wirkung von
loose. Stimmt hier der Default? Sieht eher aus, als funktioniert das nicht...

In Opera (Version 10.6) geht in der Sidebar das Scrollen per Mausrad nicht.

Der Check ntp ist durch 'ntp.peer' in den meisten Fällen obsolet geworden.
Die Inventur findet immer beide, was blöd ist. Soll man ignored_checktypes
vorbelegen mit ntp?

Multisite: Die neue View, welche die Services einer Hostgruppe darstellt,
hat Darstellungsprobleme mit den Tabellenschatten, wenn die darstellung
zweispaltig ist. Komischerweise tauchen diese Probleme bei "All Services"
nicht auf, obwohl hier das gleiche Layout verwendet wird.

Multisite: Wenn man die view 'hosts' auf Tablelayout umstellt und
zwei Spalten einstellt, dann fehlt die mittlere Trennspalte, und
bei ungerade Spaltenzahl wird am Ende der zweiten Spalte nicht
eine hellgraue Zelle angezeigt, sondern eine leere mit grauen
Trennlinien, so wie früher im alten Layout von Multisite.

Multisite: All hosts (Mini) -> Edit (nix ändern) -> Try out und
jetzt auf den ersten Host klicken: => Fehlermeldung "Internal error: 
No view name and not datasource defined. (Retry with debug mode)"

Bei Inventur check_mk -I ntp werden auch die SNMP-Geraete abgefragt?
Werden die nur bei -I tcp ausgeklammert? Sollte nicht sein, sonst
bekommen wir viele Timeouts.

Multisite: Aenderung an default_user_role in multisite.mk erfordert
Apache-Neustart.

Sidebar scrollen: Wenn man ein Snapin packt, mit der Maus scrollt und
dabei die Maus über den Rand des HTML-Bereiches des Browsers rauszieht und
dort loslässt, dann bekommt die Sidebar das nicht mit. Wenn man mit der Maus
wieder reinfährt, ist man - trotz losgelassener Maus - noch im Scrollmodus.
Kann man den aktuellen Status der Maus irgendwie abfragen - so dass man das
verlorengegangene Event kompensieren kann? Oder kommt das Event irgendwo
anders an, wo man es noch abgreifen kann?

Counter wraps: Wenn ein Counter wrapped, liefert dann Check_MK eine Warnung
"got only 5 out of 9 infos?"

Livestatus: Bei bestimmten regulären Ausdrücken in ~~ schmiert Nagios
ab. Ist wohl ein Bug in glibc/regcomp. Weiss nicht, was ich da machen
kann. Beispiel:
GET hosts 
Filter: name ~~ (.*){1,346}[bc] 

Livestatus: das Nagios-Debuglog ist nicht reentrant. Livestatus muss ein eigenes
Logfile schreiben. Wir machen das ohne Rotation. Man muss einfach selbst
aufpassen, dass es nicht zu groß wird. Default ist eh aus. Ins Nagios
geloggt wird nur das Starten und Beenden (was ja im Hauptthread läuft).

Wenn man gerade die Kommandobox auf hat (oder den Filter?) dann sollte
kein Refresh stattfinden. Sonst wird man mitten im Tippen abgewürgt.
Kann man das mit Javascript hinbekommen?

Eingabe von Downtimes: Auch hier Umlaute abfangen wie bei Comments

Noch ein Problem mit Umlauten: Ein Drucker sendet per SNMP Latin1
kodierte Wert, z.B. Resttonerbehälter. Daraus baut Check_MK eine
Servicedesription, die in nagios/conf.d/check_mk_objects.cfg ein
Latin1-Zeichen enthält. Dieses wandert per Livestatus zu Multisite
und taucht dort z.B. auf als \u0084. An der Stelle, wo ein Link 
gerendert wird, kommt es jetzt zu folgendem Fehler:
File "/usr/lib/python2.5/site-packages/mod_python/importer.py", line 1537, in HandlerDispatch
    default=default_handler, arg=req, silent=hlist.silent)

      File "/usr/lib/python2.5/site-packages/mod_python/importer.py", line 1229, in _process_target
          result = _execute_target(config, req, object, arg)

      File "/usr/lib/python2.5/site-packages/mod_python/importer.py", line 1128, in _execute_target
          result = object(arg)

      File "/usr/share/check_mk/web/htdocs/index.py", line 219, in handler
          url = html.makeuri([("debug", "1")])

      File "/usr/share/check_mk/web/htdocs/htmllib.py", line 183, in makeuri
           return self.req.myfile + ".py?" + urlencode_vars(vars + addvars)

       File "/usr/share/check_mk/web/htdocs/htmllib.py", line 76, in urlencode_vars
           output += urlencode(unicode(value))

    UnicodeDecodeError: 'ascii' codec can't decode byte 0x9a in position 8: ordinal not in range(128)
-> Liegt wohl daran, dass output ascii-kodiert ist und daher += eine Zurückkodierung
erfordet. Weiteres Problem: Auch in der Nagios-GUI klappt der Service-Link nicht.
Lösung unklar. Woher können wir wissen, dass die Daten per SNMP Latin1 kodiert sind? 
Muss man hier eine Variable snmp_encodings machen, wo man pro Host etwas angeben kann,
z.B. "latin1"? Dann müsste man die Strings an geeigneter Stelle rückkodieren,
allerdings geht das wieder nicht in snmp.py direkt, weil da teilweise Bytestrings
ankommen, die nicht geändert werden dürfen. Also wo dann? Siehe dazu MFP001
im privaten GIT.

--------------------------------------------------------------------------------
UNSCHOENHEITEN
--------------------------------------------------------------------------------
Multisite Bookmarks: Das Snapin speichert immer absolute URLs mit Hostnamen.
Das ist aber doof, wenn man die Bookmarksdatei auf einen anderen Host kopiert
oder mal mit IP-Adresse, mal mit Namen auf Nagios zugreift. Lösung: Beim Speichern
der Bookmarks den gemeinsamen Pfad vorne wegschneiden.

Multisite view 'host': Warum gibt es hier keinen Knopf auf die
Probleme des Hosts? Umgekehrt gibt es so einen Knopf.

Multisite views: Die Zeilenhintergrundfarbe für UNKNOWN passt nicht.
Hier wird statt orange eher gelb und rot verwendet.

Logwatch.py: Wenn die state-Datei korrupt ist, diese neu anlegen und eine
Fakemeldung nach oben schicken, die critical ist.

Multisite: Zeitanzeige der Downtimes (ende) zu ungenau.  "in 6 hrs" ist
blöd. Auch bei Start "19 sec" ist dumm, hier wäre besser (vor 19 sec). Oder
bei Downtimes immer absolute Zeiten angeben? Evtl. Zusatzspalte der Duration.

snmp_communities: dictionary nicht mehr verwenden, aus Doku raus, Defaultwert
leere Liste, aus Code raus, Hinweis im ChangeLog. Evtl einen Test mit
Abbruch, wenn immer noch type ist dict.

bulkwalk_hosts: Hier ist der Default None und nicht []. Problem dabei
ist, dass dann ein += nicht funktioniert. Kann man nicht non_bulkwalk_hosts
ganz rausschmeissen und bulkwalk_hosts auf [] setzen? Ausserdem gibt
es ja fuer binaere Hostlisten das NEGATE (=> Doku). In 1.2 einbauen.

--------------------------------------------------------------------------------
IDEEN & VERBESSERUNGEN
--------------------------------------------------------------------------------
Kommando was dringend fehlt: Custom notification (mit force und broadcast)

Quicksearch: Hier sollte man auch nach servicenamen suchen können.
Einfach wenn man keinen passenden Host findet, in die Services-View
springen mit Filter auf Servicenamen.

Neue Spalten: * long_service_output, host_notes

Multisite: Kann man - wenn man Aggregation verwendet - beim normalen
Host einen Links auf den Summary host machen und umgekehrt? Evtl.
hartkodiert in show_view(), falls die Variable host gesetzt ist?

Multisite: icons: das Erkennen der modified_attributes
funktioniert nur halb: Wenn man den Ausgangswert wiederherstellt,
bleibt das Attribut trotzdem modified...
Kann man die modified attributes beim Nagios so einstellen,
dass diese *nicht* bei einem Restart gespeichert werden?
Sonst werden sie nie zurückgesetzt. Oder kann man das evtl.
mit einem Kommando machen? 

    Ja => CHANGE_SVC_MODATTR;<host_name>;<service_description>;<value>
    Eine Datei local.mk, die von backup/restore *nicht* beruecksichtigt wird.

Multisite: Bei einer bestehenden View muss man die Datenquelle umstellen
können, zumindest wenn die neue Datenquelle alle Spalten unterstützt,
die aktuell verwendet werden (und Filter).  Man muss z.B. von hostgroups
auf hostgroups_merged umstellen können. Alles andere ist viel zu umständlich.

Cluster: Wenn der Clustername einer IP-Adresse zugeordnet ist (
einfach mit Check_MK-Mitteln Adresse ermitteln aus gethostbyname/ipaddresses),
dann:
 * IP in address eintragen anstelle von 0.0.0.0
 * check-mk-ping als Hostcheck verwenden

Edit view: die Spaltenzahl ist zu niedrig.

Inventur von Linux-NICs: Nur verwendete Karten monitoren.

Doku Windows:
 C:\> lodctr /s:c:\counter.txt
 ==> Holt aus der Registry die Namen und Beschreibungen der
 ganzen Performancecounter :-)

Die Option -d verwendet --cache nicht.

Filter für last_checked und last_state_change

Anstelle der Pipe direkt checkresults-Dateien schreiben

check_mk -C soll Liste von Hosts bekommen können.

Bei Hosts, die kein keine Services haben, eine andere
Host-Schablone nehmen, die den Hostcheck nur on-demand ausführt.

Multisite: man kann bei Comments keine Umlaute eingeben. Diese sind aktuell
verboten, weil Python sonst Exceptions wirft.  Komischerweise kann man
in den Filtern problemlos Umlaute eingeben. Keine Ahnung, wo hier der
Unterschied liegt.

Multisite: ein Filter für Hosts, der dann zuschlägt, wenn ein Host
einen bestimmten Service hat (geht das auch mit Substrings?)

Windows-Agent: Speicherberechung von Swap anpassen und Check mem entsprechend
anpassen, dass er TotalPage und UsedPage verwendet. Im Quellcode ist das schon
drin, der Check muss angepasst werden und auch die Schablone. Evtl. macht
man einen eigenen Check. Oder man löst es über das Check-Item.

Die impliziten Services Check_MK und PING und evtl. legacy_checks auch durch
die Konfigmaschine laufen lassen, damit Servicegruppen etc auch funktoinieren
(auch Inventory-Checks).  PING: service_notification_period und andere
Eigenschaften wie Gruppen, etc werden eicht berücksichtigt. Gleiches gilt
für Servicegruppen. Man sollte daher die Funktion extra_service_conf_of()
so erweitern, dass *alles* Nagios-Attribute agbefrühstückt werden.

check_mk --restore: Löscht er cache und counters? Er sollte nur die
Inhalte löschen. Es könnte nämlich sein, dass es sich nicht um Verzeichnisse,
sondern um Symlinks handelt.

check_mk --uninstall backup.tar.gz: Deinstalliert alle Dateien, die
setup installiert hat. Dazu verwendet man einfach die Pfade, die setup.sh
gespeichert hat (reicht das?). Man wird dabei gezwungen, vorher ein
Backup durchzuführen.

Livestatus-Limit-Header könnte auch einen Bereich erlauben, z.B.:
Limit: 1000 2000 (holt die zweiten Tausend Eintraege...)

Windows: Der Agent sollte die Logmeldungen nach UTF-8 konvertieren. 
Nur wie?

Logwatch: Hier sollte man wirklich einen Teil der Meldung ausgeben.
Kann man evtl. den long_service_output verwenden?

Performance counter: Generell sollten *alle* Counter von Check_MK
behandelt werden mit get_counter und *nicht* als counter in die
RRDs geschrieben, sondern bereits als Rate. Dadurch muss man alle
Graphen einmal wegwerfen. Das ist blöd. Vorteil allerdings: (1)
man kann Perf-O-Meter machen, (2) die Counter-Wrap-Erkennung
verhindert, dass in den RRDs nach einem Reboot utopische Werte
stehen (z.B. für die Kernel counter). (3) Da in den Performancedaten
bereits eine Rate steht, können auch Tools wie NagVis dafür eine
Visualisierung machen.

Multisite: Perf-O-Meter für weitere Checks einbauen.

Logfile ansicht: Filter zum suchen nach Texten.

View editor: Wenn man keine Display columns ausgewaehlt
hat, dann sollte eine Fehlermeldung kommen.

Windows services: Konfiguration von Namen für die Services
über 
  windows_service_aliasses = {
     'ACDSee Lizenzserver' : 'ProductCommunicationService',
  }
Der Schlüssel ist dabei der logische Name. Oder man macht es
umgekert. Verfahren: Als item wird der logische Alias-name
speichert. So taucht dieser dann in der Service-Description
auf. Beim Check kommt der logische Name rein. Mit dem dict
kann ich daraus den physischen berechnen und so die richtige
Zeile finden. Oder ich kann umgekehrt jede Zeile im dict
zum Physischen namen den Alias nachschlagen und so zu Zuordnung
machen.

Livestatus: Bei den Tabellen hosts und services fehlt die
Spalte 'contact_groups'. Man bekommt zwar die Einzelkontakte,
aber nicht die Gruppen. Bei den Nagios-Datenstrukturen gibt
es aber einen passenden Zeiger dafür. Sollte also nicht schwer
sein, das umzusetzen.

Livestatus: Beim Empfangen von Queries gibt es zwei Timeouts:
den für eine Zeile, den für eine Queriy. Beide sollte man 
konfigurieren können und auch evtl. im Default etwas erhöhen.

Checkboxen: Bei einer View macht man oben einen kleinen Reiter,
der eine Checkbox symbolisiert. Wenn man den anklickt, wir bei
jedem Datensatz zusätzlich eine Checkbox angezeigt. Das wird
als Viewoption persistiert und auch general als Layout-Parameter
angeboten. Wenn die Checkboxen sichtbar sind, werden Kommandos
nur noch auf die Datensätze angewandt, welche mit einem Kreuz
markiert sind. Zur Steigerung des Bedienkomforts gibt es einen
Knopf, mit dem man alle Boxen markieren oder leeren kann
(evtl. kann man das auch darüber regeln, dass der Reiter
oben nicht zwei, sondern drei Zustände hat: Checkboxen aus,
Checkboxen alle gecheckt, Checkboxen alle leer).
Damit die Checkboxen funktionieren, muss jeder Datensatz eine
eindeutige ID erzeugen können. Dazu gibt es bei jeder Datasource
die Information, welche Spalten das sind. Aktuell gibt es
dazu schon "keys". Problem hier ist nur, dass da noch die
Downtime-IDs mitkommen, die man hier nicht braucht. Diese
sollte man irgendwie weglassen können.
Die Checkbox bekommt also also HTML-Variablennamen die jeweilige
ID - irgendwie enkodiert so dass es keine Probleme mit 
Sonderzeichen gibt.
Wenn die Schleife der Kommandos ausgeführt wird, muss ich
jeweils noch kontrollieren, ob der Datensatz, um den es
gerade geht, auch gecheckt ist (oder Checkboxen generell
aus sind). Wenn Kein Datensatz gewählt wurde, spucke ich
eine Fehlermeldung aus.

Views: Man könnte eine ASCII-View bauen, die kein HTML ausspuckt, sondern
simples ASCII. Frage ist dabei, was man mit den Paintern macht. Hier müsste
man die sichtbare Information aus den HTML-Tags rausholen, also eine Art
HTML->ASCII Filter programmieren. Auch die Überschrift ist dann betroffen
und die Fusszeile. Analog dazu könnte man sich eine Ausgabe als CSV oder
XML vorstellen. Hintergrund ist eine Art Webservice.

Precompile und Konfigerzeugung: Das könnte auf mehrere CPUs skalieren.
Dazu starten man konfigurierbar viele Threads. Bei Precompiled macht
einfach jeder der N Threads ein N'tel der Hosts. Bei der Konfigerzeugung
müsste man die Konfig zunächst im Speicher erzeugen und dann die Ergebnisse
der 8 Threads am Ende zusammenbauen. Davor muss aber die Umstellung
der Konfigerzeugung gemacht werden, bei der immer ein Host und
seine Services gemeinsam ausgespuckt werden.

Idee zur Umbenennung von Konfig-Parametern: Wenn z.B. eine Konfigvariable
hirn hieß und jetzt sepp heißen soll, dann könnte man dies Deklarieren
in check_mk.py:
renamed_config_vars = [
  ( "hirn", "depp", 1127002033 )
]
Jetzt könnte man vor dem Einlesen der Konfig die Ist-Werte speichern,
und zwar mit Objektreferenzen, um festzustellen, ob der Benutzer
hier etwas geändert hat. Alernativ schaut man nach globals:
# Nach dem Einlesen der Konfig:
for old, new, deadline in renamed_config_vars:
  if old in globals():
      sys.stderr.write("WARNING: Config var '%s' has been renamed to '%s'. Please fix this until %s" % (old, new, strftime(deadline...)))
      if time.time() < deadline:
          eval("%s = '%r'" % (new, eval(old)))
      else:
          sys.stderr.write("You had enough time to fix this. Sorry.\n")
          sys.exit(1)
Auf diese Art funktioniert erstmal alles weiter. Trotzdem wird die Variable
irgendwann planmäßig abgeschaltet.

Multisite: Checkboxen: [1] Neuer Reiter mit drei Zuständen: keine Checkboxen
alle gecheckt, alle leer. Der Zustand wird als viewoption persistent und
auch bei der View als Parameter eingebaut, so dass der Admin einen Default
vorgeben kann. Evtl. kann die View auch festlegen, ob überhaupt ein Reiter
kommt. [2] Beim Anzeigen eines Layouts muss diese eine extra TD malen,
welches eine Checkbox enthält (wenn der Reiter sichtbar ist).  Der Name der
Checkbox muss über eine eindeutige Zeilen-ID bestimmt sein.  und man muss -
nach der Tabelle - ein eine Javascript-Funktion ausgeben, die das Umschalten
der über das Tab regelt - alle an / alle aus, umschalten.  Das muss dann
per Ajax auch die View-Option umstellen und die Optik des Tabs ändern. Wenn
man auf unsichtbar schaltet, müssen alle Boxen auf gecheckt gesetzt werden,
damit das Kommando auch wirklich auf allen ausgeführt wird. [3] Wenn man
jetzt auf ein Kommando klickt, muss ich bei jedem Datensatz wieder die ID
berechnen. Dann schauen, ob es eine Check-Variable gibt. Falls ja, muss
diese auf "on" stehen, damit das Kommando ausgeführt wird.  Wenn keines
gewält ist, soll ein Hinweis kommen (gelb).

View options für Painter: Ein Painter hat eine Liste von Painter-Viewoptions.
Dazu gibt es ein dict: painter_view_options["pnpsource"] = { 
( "PNP Timerange", "1", [("0":"4 hours"), ("1", "24 hours"), ... ] )
Vor dem Anzeigen des Layouts ermittle ich alle benötigten View-Options.
Analog zu refersh mache ich Persisitierung und HTML-Variablen-Auswertung
und komme zu einem Ergebnis. Das speichere ich dann in view_option["pnpsource"].
Dies kann der Painter einfach abfragen. Einsatz: PNP-Zeitraum, Darstellung
von Zeitstempeln (Delta/Absolute/Mixed).

Livestatus: Anstelle von Gesamttimeout beim Querylesen einen Timeout
zwischen zwei Zeilen machen. Also immer wenn eine Zeile gelesen wurde,
den Zähler wieder auf Null setzen. Gleichzeitig die mazimale Größe
des Queries begrenzen per Config-Option. 

Multisite: Wenn man bei einer View einen Filter ausfüllt (user), dann
soll irgendwo ein Icon anzeigen, dass das Resultat gefiltert ist.

Multisite: Hover: Wenn man über einen Painter geht, könnte man eine
Hover aufmachen, der einen weiteren Painter anzeigt. Das macht man
über eine Auswahlbox analog zu der "Link to".

Vorschlag von Bastian: Bei den Views könnte man den Datenbereich (Tabelle)
per Ajax refreshen und müsste nicht die ganze Seite neu aufbauen. Damit
wird ein Bildschirmflimmern vermieden.

Vorschlag(2) von Bastian: 
    Der Agent spucht zwei neue Zeilen aus:
    StartTime: 127006756
    ..
    ..
    ..
    End Time: 127007654
    
    Check_MK prüft daraus:
    1. Ausführzeit des Agenten
    2. Alter der Daten (z.B. für asynchrone Agenten)
    
    In der main.mk muss man jetzt konfigurieren können, was
    passiert, wenn die Zeiten zu hoch sind. Z.B.:
    
    agent_execution_time_default_levels = (10, 30)
    agent_execution_time_levels = [ 
      # ORACLE-Rechner brauchen länger
      ( (30, 50), ["oracle"], ALL_HOSTS ),
    ]
    
    agent_freshness_default_levels = (5, 10)
    agent_freshness_levels = [
      ( ( 60, 90), [ "async" ], ALL_HOSTS ),
    ]
    
    Das ganze wird geprüft vom Hauptcheck. Wenn bei der
    freshness der kritische Wert zieht, werden die
    Resultate verworfen und die Checks nicht ausgeführt
    
Livestatus soll im Logfile eine Warnung ausgeben, wenn die
environment_macros aktiviert sind.

FreeBSD Agent:
  Auf der Homepage sollte ein Hinweis platziert werden, dass es einen neuen
  Agent gibt. Dieser basiert zwar auf dem Linux Agenten, gibt momentan aber
  wesentlich weniger Daten aus, da die Sektionen noch nicht portiert sind.
  
  Dazu wird eine Beschreibung benötigt, wie dieser zu installieren ist.
  1. inetd installieren
  2. /etc/services hinzufügen:
  check_mk_agent  6556/tcp   # Check_MK's agent
  3. /etc/inetd.conf hinzufügen:
  check_mk_agent  stream  tcp     nowait  root    /usr/bin/check_mk_agent check_mk_agent
  4. inetd neu starten
  -> Eventuell noch ein anderer Pfad für den Agent (?). Gibt es da andere Vorgaben
     auf FreeBSD Systemen?
  
  Die Sektionen/Checks ps und postfix_mailq sind jetzt schon kompatibel.

Idee: Bei SNMP-Checks gibt es manchmal Daten, die sich dynamisch nicht ändern
(z.B. Interfacenamen, etc.). Man könnte diese Daten cachen, so dass sie nicht
jedes mal geholt werden, sondern z.B. nur alle 10 Minuten.

Bei "Invalid output from plugin" könnte man noch einen Hinweis machen, dass
man die --debug-Option verwenden soll. Am besten wäre gleich ein Link
auf meine Homepage auf einen Artikel dazu!

IDEE: Prefetching agent: Der agent soll die Daten schon berechnen kurz bevor
sie abgefragt werden. Das ganze läuft so: Zunächst ermittelt der Agent,
wie lange die Datenberechnung im Schnitt dauert (z.B. über schleichenden
Mittelwert), sagen wir 5 Sekunden. Über den gleichen Wert ermittelt er, wie
oft er abgefragt wird, sagen wir alle 60 Sekunden. Wenn der Agent kontaktiert
wird, kann er dann einen günstigen Zeitpunkt ermitteln, zu dem er beginnt,
die Daten aufzubereiten.  Im Beispiel ist das spätestens 55 Sekunden nach
der letzten Anfrage, mit etwas Puffer kann man z.B. 5 Sekunden früher
beginnen. Das ganze schützt man über ein Lock, so dass wenn das Prefetch
noch nicht begonnen hat oder nicht fertig ist, wenn eine Anfrage kommt,
der Anfrager warten muss. Ergebnis: Auf eine Anfrage kommt im Optimalfall
immer *sofort* ein Ergebnis. Außerdem kann das Berechnen mit nice laufen.
Das könnte man auch in den Windows-Agenten integrieren und so die Probleme
beheben, die auftreten, wenn das System unter hoher Last steht.


Options --list-tags, welche alle Tags ausgibt.

PNP4Nagios+Multisite: Javascript plus Webservice von Jörg benutzen,
um festzustellen, welche Grafen es zu einem Service gibt.
pnp4nagios/index.php/json?host=<hostname>&srv=<servicedesc> 

