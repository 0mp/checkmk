--------------------------------------------------------------------------------
NOCH INS RELEASE 1.1.4
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
BUGS
--------------------------------------------------------------------------------
Multisite view pending: Host output statt service output. View
übersichtlicher bauen.

Icinga 1.0.1 mit Livestatus hing nach dem Beenden in futex:

# strace -p 25739
Process 25739 attached - interrupt to quit
futex(0x7fb7f4d399f4, FUTEX_WAIT_PRIVATE, 2, NULL
        
(gdb) bt
#0  0x00007fb7f4abc76e in ?? () from /lib/libc.so.6
#1  0x00007fb7f4a63f3d in ?? () from /lib/libc.so.6
#2  0x00007fb7f4a63cf7 in ?? () from /lib/libc.so.6
#3  0x00000000004408df in get_datetime_string ()
#4  0x0000000000431acc in grab_datetime_macro ()
#5  0x0000000000434085 in grab_macrox_value ()
#6  0x00000000004348b3 in set_macrox_environment_vars ()
#7  0x00000000004348ed in set_all_macro_environment_vars () <=== ***
#8  0x0000000000419313 in run_async_host_check_3x ()
#9  0x000000000041b50f in run_scheduled_host_check_3x ()
#10 0x000000000041b6ba in perform_scheduled_host_check ()
#11 0x000000000042b44b in handle_timed_event ()
#12 0x000000000042b8a1 in event_execution_loop ()
#13 0x0000000000413ef2 in main ()

--> Haenger ist wahrscheinlich abhaengig von dem Setzen
der Umgebungsvariablen.

Im Quellcode von get_datetime_string() sieht man, dass
die Funktion localtime() oder gmtime() verwendet wird.
Beide sind *nicht* threadsafe. Gut möglich, dass die
libc sich hier mit einem futex-schützt. Andere Aufrufe
in die libc gibt es nicht, außer snprintf, der sicherlich
kein Problem machen dürfte. ==> Sieht aus wie ein Bug
in Nagios. Besser, man stellt die Umgebungsvariablen ab.

Haenger von Nagios 3.2.0. Diesmal an dieser Stelle:

#0  0x00fad410 in __kernel_vsyscall ()
#1  0x009acde3 in __lll_lock_wait_private () from /lib/libc.so.6
#2  0x009529eb in _L_lock_1790 () from /lib/libc.so.6
#3  0x00952784 in __tz_convert () from /lib/libc.so.6
#4  0x00950daf in localtime () from /lib/libc.so.6
#5  0x08083636 in get_datetime_string ()
#6  0x08074c9c in grab_datetime_macro ()
#7  0x08077166 in grab_macrox_value ()
#8  0x08077a2c in set_macrox_environment_vars ()
#9  0x08077a61 in set_all_macro_environment_vars () <=== ***
#10 0x08084033 in my_system ()
#11 0x080b5528 in xpddefault_run_service_performance_data_command ()
#12 0x080b55b2 in xpddefault_update_service_performance_data ()
#13 0x080b4f29 in update_service_performance_data ()
#14 0x0805f305 in handle_async_service_check_result ()
#15 0x080603ed in reap_check_results ()
#16 0x0806e3f5 in handle_timed_event ()
#17 0x0806eac7 in event_execution_loop ()
#18 0x080567ac in main ()

In beiden Fällen hängt nicht der Hauptprozess von Nagios im
Lock, sondern ein Sohnprozess. Der Hauptprozess wartet auf
die Beendigung des Sohnprozesses. Die anderen Sohnprozesse sind
Zombies und warten darauf, dass Nagios sie wegwaitet.

*** An dieser Stelle werden alle Umgebungsvariablen gesetzt. Ein Workaround
kann daher sein, die Umgebungsvariablen auszuschalten. Fraglich ist allerdings,
wo das Problem eigentlich herkommt. Welcher Thread bleibt inmitten von localtime()
hängen und gibt das Lock nicht frei? Was ist eigentlich, wenn sich ein Thread
beendet, ohne ein bestimmtes Lock freizugeben? Bleibt das hängen oder wird
es automatisch freigegeben? Und was passiert, wenn ein Prozess geforkt wird,
während ein anderer Thread des Prozesses gerade ein Lock hält? Wird das Lock
vererbt an den neuen Prozess im Zustand "gehalten"? Kann es also sein, dass
wenn Nagios einen Unterprozess abforkt() während gerade ein anderer Thread
localtime() aufruft, dass im Unterprozess das Lock gesperrt ist?

Hier ein Auszug aus der Manpage von pthread_atfork():

   To understand the purpose of pthread_atfork, recall that fork(2) dupli‐
   cates the whole memory space, including mutexes in their current  lock‐
   ing  state,  but only the calling thread: other threads are not running
   in the child process.  The mutexes are not usable after  the  fork  and
   must be initialized with pthread_mutex_init in the child process.  This
   is a limitation of the current implementation and might or might not be
   present in future versions.

Soll das bedeuten, dass man einen Prozess mit Threads nicht mehr forken
kann?



Abgesehen davon ist localtime nicht threadsafe. Da Nagios selbst threads
verwendet, darf es eigentlich localtime nicht verwenden.

Was machen die anderen Threads?
Einer kommt von Nagios:
#0  0x00fad410 in __kernel_vsyscall ()
#1  0x00996973 in poll () from /lib/libc.so.6
#2  0x0807fdf9 in command_file_worker_thread ()
#3  0x00f0749b in start_thread () from /lib/libpthread.so.0
#4  0x009a042e in clone () from /lib/libc.so.6
Der nächste ist der Hauptthread von Livestatus, der auf neue Verbindungen
auf dem Socket wartet. 
Die restlichen Zehn sind die Livestatus-Clientthreads, welche darauf
warten, dass der Hauptthread eine Verbindung in die Queue schmeisst:
#0  0x00fad410 in __kernel_vsyscall ()
#1  0x00f0b595 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0
=> Das sieht alles völlig normal aus.

--> Meine Analyse des Problems:

Nagios macht folgendes, wenn es ein Kommando ausführt (my_system): Es
forkt() sich zunächst einmal. Dann setzt es alle Umgebungsvariablen (wenn
dies in nagios.cfg aktiviert ist). Der Unterprozess startet dann erst
mit popen() den eigentlichen Sohnprozess, liest dessen Ausgabe, wartet
bis er fertig ist und beendet sich dann selbst.

Bei Setzen der Umgebungsvariablen wird - wohl wegen Zeitangaben in den Variablen-
texten - wird localtime() aufgerufen. Innerhalb von localtime() wird ein
Lock verwendet (in glibc eingebaut). Wenn just während des Forkens aber
ein anderer Thread in just diesem Lock steckte (das Lock muss was mit der
Zeitzone zutun haben, weil es von _tz_convert aufgerufen wird), dann erbt
der Sohnprozess das Lock im gelockten Zustand. Die Funktion localtime()
hängt dann für alle Ewigkeit. 

Die Frage ist: Wer hat das Lock belegt? Theoretisch kommt natürlich auch
Livestatus in Frage. Hier müsste man per gdb oder strace mal kontrollieren,
welche Funktion der glibc das gleiche Lock verwendet. Livestatus verwendet
nämlich localtime() nicht. Das Nagios selbst localtime verwendet kann das
Problem hier her kommen. 

Workaround: Environment macros unbedingt abschalten.

--------------------------------------------------------------------------------
UNSCHOENHEITEN
--------------------------------------------------------------------------------
Multisite tactical overview: Hier muss man Summary hosts ausschliessen.
Soll man die Filter doch irgendwie konfigurierbar machen? Oder doch
einfach an hostproblems und serviceproblems haengen??

Kachellayout von Multisite: Farben sind so, dass man nix erkennt.

Logwatch.py: Wenn die state-Datei korrupt ist, diese neu anlegen und eine
Fakemeldung nach oben schicken, die critical ist.

Tabledarstellung mit Gruppen: Hier klebt der Gruppenkopf zu dicht
an der vorherigen Gruppe.

Multisite: Zeitanzeige der Downtimes (ende) zu ungenau.  "in 6 hrs" ist
blöd. Auch bei Start "19 sec" ist dumm, hier wäre besser (vor 19 sec). Oder
bei Downtimes immer absolute Zeiten angeben? Evtl. Zusatzspalte der Duration.

logwatch.php und die anderen htdocs/* -Dateien rausschmeissen, nicht mehr
installieren. Im setup auch das Eintragen von var_dir entfernen. Eventuell
vorher oben einen Text einbauen mit Link auf das neue Logwatch.

snmp_communities: dictionary nicht mehr verwenden, aus Doku raus, Defaultwert
leere Liste, aus Code raus, Hinweis im ChangeLog. Evtl einen Test mit
Abbruch, wenn immer noch type ist dict.

Multisite: Bei Änderungen an der Konfigdatei (debug) muss man komischerweise
Apache neu starten....

--------------------------------------------------------------------------------
IDEEN & VERBESSERUNGEN
--------------------------------------------------------------------------------
Multisite: icons: das Erkennen der modified_attributes
funktioniert nur halb: Wenn man den Ausgangswert wiederherstellt,
bleibt das Attribut trotzdem modified...
Kann man die modified attributes beim Nagios so einstellen,
dass diese *nicht* bei einem Restart gespeichert werden?
Sonst werden sie nie zurückgesetzt. Oder kann man das evtl.
mit einem Kommando machen? 

    Ja => CHANGE_SVC_MODATTR;<host_name>;<service_description>;<value>
    Eine Datei local.mk, die von backup/restore *nicht* beruecksichtigt wird.

Multisite: Bei einer bestehenden View muss man die Datenquelle umstellen
können, zumindest wenn die neue Datenquelle alle Spalten unterstützt,
die aktuell verwendet werden (und Filter).  Man muss z.B. von hostgroups
auf hostgroups_merged umstellen können. Alles andere ist viel zu umständlich.

Cluster: Wenn der Clustername einer IP-Adresse zugeordnet ist (
einfach mit Check_MK-Mitteln Adresse ermitteln aus gethostbyname/ipaddresses),
dann:
 * IP in address eintragen anstelle von 0.0.0.0
 * check-mk-ping als Hostcheck verwenden

Edit view: die Spaltenzahl ist zu niedrig.

Inventur von Linux-NICs: Nur verwendete Karten monitoren.

Doku Windows:
 C:\> lodctr /s:c:\counter.txt
 ==> Holt aus der Registry die Namen und Beschreibungen der
 ganzen Performancecounter :-)

Die Option -d verwendet --cache nicht.

Searcher für last_checked

Anstelle der Pipe direkt checkresults-Dateien schreiben

check_mk -R koennte statt restart ein reload machen.
Oder eine eigene option, check_mk -O?

check_mk -C soll Liste von Hosts bekommen können.

Generieren der Host- und Serviceconf umbauen und in einer gemeinsamen Schleifen
machen. Dabei stets zuerst die Services und dann die Hosts generieren.
Denn dann kann ich bei den Hosts schon wissen, ob es services gibt und für
die PING-only hosts eine andere Schablone nehmen, wo die check_interval
für Hostchecks auf 0 ist, also nur on-demand-pings ausgeführt werden
(damit man nicht doppelt pingt).

Multisite: man kann bei Comments keine Umlaute eingeben. Diese sind aktuell
verboten, weil Python sonst Exceptions wirft.  Komischerweise kann man
in den Filtern problemlos Umlaute eingeben. Keine Ahnung, wo hier der
Unterschied liegt.

Windows-Agent: Speicherberechung von Swap anpassen und Check mem entsprechend
anpassen, dass er TotalPage und UsedPage verwendet. Im Quellcode ist das schon
drin, der Check muss angepasst werden und auch die Schablone. Evtl. macht
man einen eigenen Check. Oder man löst es über das Check-Item.

Die impliziten Services Check_MK und PING und evtl. legacy_checks auch durch
die Konfigmaschine laufen lassen, damit Servicegruppen etc auch funktoinieren
(auch Inventory-Checks).  PING: service_notification_period und andere
Eigenschaften wie Gruppen, etc werden eicht berücksichtigt. Gleiches gilt
für Servicegruppen. Man sollte daher die Funktion extra_service_conf_of()
so erweitern, dass *alles* Nagios-Attribute agbefrühstückt werden.

Check ps (Linux) mit Uberwachung von MEM (Resident) und CPU.

