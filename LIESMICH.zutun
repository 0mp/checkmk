Livestatus: is_contact_member_of_contactgroup selbst programmieren,
    da diese Funktion in Nagios rausfliegen wird.

Doku: Check_MK und OMD: Installieren von MKPs, local-Hierarchie

Multisite: Kontextknöpfe Services: OK, Services: Crit usw. unsichtbar
machen. Dazu einen neue View-Option einbauen (hide context button).

Multisite: Bei jedem aktiven Service soll ein Knopf angezeigt werden
zum Reschedulen. Dieser soll dann per WaitCondition: so lange warten,
bis der Check auch wirklich ausgeführt wurde!

Inventurcheck: retry_interval evt. anders (kuerzer) einstellbar machen.

--------------------------------------------------------------------------------
BUGS beheben ab 1.1.9i1
--------------------------------------------------------------------------------
WATO Snapin: ajax-Code zum Ausgeben der Links stimmt nicht. Er nimmt
einfach die Site-ID als URL-Prefix. Das ist aber nicht immer korrekt.
Man kann in sites eine site "local" nennen, aber der URL-Prefix ist
z.B. /wato/.

ich bin mir nicht sicher ob das nun ein Thruk Problem oder ein Livestatus Problem ist. Vermutlich beides :-)
Wenn ich im Thruk im Suchfenster einfach Enter drücke, kommt folgende Query bei raus:
GET services
Columns: ..
Filter: description ~~ 
Filter: groups >= 
Filter: plugin_output ~~ 
Filter: long_plugin_output ~~ 
Filter: host_name ~~ 
Filter: host_alias ~~ 
Filter: host_groups >= 
Filter: comments ~~
Filter: downtimes ~~
Or: 2
Or: 8
livestatus: Sorry, Operator 4 for lists not implemented.


Noch ein Problem mit Umlauten: Ein Drucker sendet per SNMP Latin1
kodierte Wert, z.B. Resttonerbehälter. Daraus baut Check_MK eine
Servicedesription, die in nagios/conf.d/check_mk_objects.cfg ein
Latin1-Zeichen enthält. Hier sollte unbedingt UTF-8 verwendet
werden. Nur: woher kennen wir die Kodierung vom Drucker??

Livestatus: bestimmte UTF-8 Zeichen werden nicht korrekt kodiert, z.B. "€".
Um das umzustellen, muss man wahrscheinlich einfach UTF-8 generell
annehmen.

Wenn ein Counter Wrap passiert und der check selbst die Exception
nicht abfängt, dann wird das Ergebnis nicht an Nagios weitergeleitet.
Der Service wird auch nicht in die aggregierten Services eines Summary Hosts
aufgenommen. Das kann dazu führen, dass die Anzahl der Services in einem
Summary-Host variabel ist.

Cluster-Inventur: Wenn ein Service auf der Node sitzt und man die Regeln
zu Clustered services ändert, entfernt ein -II das nicht von der node

Livestatus: wenn man mehrere StatsGroupBy macht, wird der Speicher von den 
alten nicht freigegeben (ist momentan eh nicht erlaubt. Fehlermeldung ausgeben).
In neuer Version sollte man irgendwann mehrere Group-Header erlauben.

Multisite: Table log: Hier wird nur der erste Site angezeigt, bzw. die Chronologie
Reihenfolge stimmt nicht. Sortieren nach Sekunden plus Zeilennummer.

MULTISITE: IE8: Multisite view: wenn man den Edit-Knopf nicht hat, dann werden
die Tabs ganz komisch ueber die ganze Breite verteilt. Ich glaube, dass ich
die ganze Implementierung der Tabs nochmal anders programmiere. Das ist viel
zu kompliziert gelöst. Ich mache die Tabs doch mit Tabellen und -moz-rounded-border.
IE hat einfach Pech gehabt und bekommt eckige Kanten.

Logwatch: was macht man hier bei verteilten Umgebungen?? Muss man das wie
PNP per Proxy anfahren? Was ist aber dann, wenn man dort rumklickt?  Dann hat
man rechts plötzlich ein anderes System. Lösung ist noch nicht in Sicht.

LARS: Bei Opera kann man kein Snapin nach ganz unten ziehen. Der Indikator 
springt dann immer nach ganz oben.

LARS: Im Opera wird sich die aktuelle Scroll-Position der Sidebar nicht korrekt gemerkt.

LARS: Wenn man gerade die Kommandobox auf hat (oder den Filter?) dann sollte
kein Refresh stattfinden. Sonst wird man mitten im Tippen abgewürgt.  Kann man
das mit Javascript hinbekommen? (kann Lars sich hier was überlegen? Man
müsste das im Javascript irgendwie dynamisch machen).  LARS: Hast du eine
Idee, wie man das (einfach) hinbekommen könnte?

Livestatus: das Nagios-Debuglog ist nicht reentrant. Livestatus muss ein eigenes
Logfile schreiben. Wir machen das ohne Rotation. Man muss einfach selbst
aufpassen, dass es nicht zu groß wird. Default ist eh aus. Ins Nagios
geloggt wird nur das Starten und Beenden (was ja im Hauptthread läuft).

Windows-Agent: Memory-Check neu machen. Swap stimmt nicht. Evtl. zwei
getrennte Checks für Memory and Pagefile.

<<<<<<< HEAD
=======
Ansicht Hostgruppen: Auch wenn man die Gruppierung nach Sites ausschaltet,
bleibt die Ansicht weiterhin nach Sites gruppiert? --> Sortierung falsch.
>>>>>>> 904ac8da2097d928201e4c7a177e85ad51a01895

-------------------------------------------------------------------------------
ab 1.1.9i1:
--------------------------------------------------------------------------------
PNP4Nagios-Popups automatisch einbauen, mit eigenen intelligenten
Icons.

Host- und Serviceicons (icon_image) anzeigen.

Aliasse einbauen (Wrappen in bin/):
    cmk = check_mk
    mkp = check_mk -P


--------------------------------------------------------------------------------
ab 1.1.11i1

filesystem_levels wirklich rausnehmen. Hinweis, dass check_parameters verwendet
werden soll.

[""] deprecaten, aus der Doku raus und durch ALL_SERVICES ersetzen. Das geht
aber erst, wenn eine stabile Version das ALL_SERVICES erlaubt!

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
UNSCHOENHEITEN
--------------------------------------------------------------------------------

Multisite Bookmarks: Das Snapin speichert immer absolute URLs mit Hostnamen.
Das ist aber doof, wenn man die Bookmarksdatei auf einen anderen Host kopiert
oder mal mit IP-Adresse, mal mit Namen auf Nagios zugreift. Lösung: Beim Speichern
der Bookmarks den gemeinsamen Pfad vorne wegschneiden.

Multisite view 'host': Warum gibt es hier keinen Knopf auf die
Probleme des Hosts? Umgekehrt gibt es so einen Knopf.

Multisite views: Die Zeilenhintergrundfarbe für UNKNOWN passt nicht.
Hier wird statt orange eher gelb und rot verwendet.

Logwatch.py: Wenn die state-Datei korrupt ist, diese neu anlegen und eine
Fakemeldung nach oben schicken, die critical ist.

Multisite: Zeitanzeige der Downtimes (ende) zu ungenau.  "in 6 hrs" ist
blöd. Auch bei Start "19 sec" ist dumm, hier wäre besser (vor 19 sec). Oder
bei Downtimes immer absolute Zeiten angeben? Evtl. Zusatzspalte der Duration.

--------------------------------------------------------------------------------
IDEEN & VERBESSERUNGEN
--------------------------------------------------------------------------------
Windows-Agent: Eventlogeinträge nach UTF-8 kodieren.

Multisite: Ein Link vom Detail-Host zum Summary-Host (umgekehrt ist er doch
schon da, oder?)

Livestatus: dritte Authorization-Regel: host_authorization: strict/loose.
Default ist strict: man muss explizit Kontakt sein, um den Host zu sehen.
Loose: wenn man für mindestens einen Service des Hosts Kontakt ist, kann
man ihn sehen.

Kommando was dringend fehlt: Custom notification (mit force und broadcast)

Neue Spalten für Views: * long_service_output, host_notes

Multisite: Kann man - wenn man Aggregation verwendet - beim normalen
Host einen Link auf den Summary host machen und umgekehrt? Evtl.
hartkodiert in show_view(), falls die Variable host gesetzt ist?

Multisite: icons: das Erkennen der modified_attributes
funktioniert nur halb: Wenn man den Ausgangswert wiederherstellt,
bleibt das Attribut trotzdem modified...
Kann man die modified attributes beim Nagios so einstellen,
dass diese *nicht* bei einem Restart gespeichert werden?
Sonst werden sie nie zurückgesetzt. Oder kann man das evtl.
mit einem Kommando machen? 

    Ja => CHANGE_SVC_MODATTR;<host_name>;<service_description>;<value>
    Eine Datei local.mk, die von backup/restore *nicht* beruecksichtigt wird.

Multisite: Bei einer bestehenden View muss man die Datenquelle umstellen
können, zumindest wenn die neue Datenquelle alle Spalten unterstützt,
die aktuell verwendet werden (und Filter).  Man muss z.B. von hostgroups
auf hostgroups_merged umstellen können. Alles andere ist viel zu umständlich.

Edit view: die Spaltenzahl ist zu niedrig.

Inventur von Linux-NICs: Nur verwendete Karten monitoren.

Doku Windows:
 C:\> lodctr /s:c:\counter.txt
 ==> Holt aus der Registry die Namen und Beschreibungen der
 ganzen Performancecounter :-)

Die Option -d verwendet --cache nicht.

Anstelle der Pipe direkt checkresults-Dateien schreiben

check_mk -C soll Liste von Hosts bekommen können.

Bei Hosts, die kein keine Services haben, eine andere
Host-Schablone nehmen, die den Hostcheck nur on-demand ausführt.

Multisite: ein Filter für Hosts, der dann zuschlägt, wenn ein Host
einen bestimmten Service hat (geht das auch mit Substrings?)

Windows-Agent: Speicherberechung von Swap anpassen und Check mem entsprechend
anpassen, dass er TotalPage und UsedPage verwendet. Im Quellcode ist das schon
drin, der Check muss angepasst werden und auch die Schablone. Evtl. macht
man einen eigenen Check. Oder man löst es über das Check-Item.

check_mk --restore: Löscht er cache und counters? Er sollte nur die
Inhalte löschen. Es könnte nämlich sein, dass es sich nicht um Verzeichnisse,
sondern um Symlinks handelt.

check_mk --uninstall backup.tar.gz: Deinstalliert alle Dateien, die
setup installiert hat. Dazu verwendet man einfach die Pfade, die setup.sh
gespeichert hat (reicht das?). Man wird dabei gezwungen, vorher ein
Backup durchzuführen.

Livestatus-Limit-Header könnte auch einen Bereich erlauben, z.B.:
Limit: 1000 2000 (holt die zweiten Tausend Eintraege...)

Windows: Der Agent sollte die Logmeldungen nach UTF-8 konvertieren. 
Nur wie?

Logwatch: Hier sollte man wirklich einen Teil der Meldung ausgeben.
Kann man evtl. den long_service_output verwenden?

Performance counter: Generell sollten *alle* Counter von Check_MK
behandelt werden mit get_counter und *nicht* als counter in die
RRDs geschrieben, sondern bereits als Rate. Dadurch muss man alle
Graphen einmal wegwerfen. Das ist blöd. Vorteil allerdings: (1)
man kann Perf-O-Meter machen, (2) die Counter-Wrap-Erkennung
verhindert, dass in den RRDs nach einem Reboot utopische Werte
stehen (z.B. für die Kernel counter). (3) Da in den Performancedaten
bereits eine Rate steht, können auch Tools wie NagVis dafür eine
Visualisierung machen.

Multisite: Perf-O-Meter für weitere Checks einbauen.

Logfileansicht: Filter zum Suchen nach Texten.

View editor: Wenn man keine Display columns ausgewaehlt
hat, dann sollte eine Fehlermeldung kommen.

Windows services: Konfiguration von Namen für die Services
über 
  windows_service_aliasses = {
     'ACDSee Lizenzserver' : 'ProductCommunicationService',
  }
Der Schlüssel ist dabei der logische Name. Oder man macht es
umgekert. Verfahren: Als item wird der logische Alias-name
speichert. So taucht dieser dann in der Service-Description
auf. Beim Check kommt der logische Name rein. Mit dem dict
kann ich daraus den physischen berechnen und so die richtige
Zeile finden. Oder ich kann umgekehrt jede Zeile im dict
zum Physischen namen den Alias nachschlagen und so zu Zuordnung
machen.

Livestatus: Bei den Tabellen hosts und services fehlt die
Spalte 'contact_groups'. Man bekommt zwar die Einzelkontakte,
aber nicht die Gruppen. Bei den Nagios-Datenstrukturen gibt
es aber einen passenden Zeiger dafür. Sollte also nicht schwer
sein, das umzusetzen.

Checkboxen: Bei einer View macht man oben einen kleinen Reiter, der eine
Checkbox symbolisiert. Wenn man den anklickt, wir bei jedem Datensatz
zusätzlich eine Checkbox angezeigt. Das wird als Viewoption persistiert und
auch general als Layout-Parameter angeboten. Wenn die Checkboxen sichtbar sind,
werden Kommandos nur noch auf die Datensätze angewandt, welche mit einem
Kreuz markiert sind. Zur Steigerung des Bedienkomforts gibt es einen Knopf,
mit dem man alle Boxen markieren oder leeren kann (evtl. kann man das auch
darüber regeln, dass der Reiter oben nicht zwei, sondern drei Zustände
hat: Checkboxen aus, Checkboxen alle gecheckt, Checkboxen alle leer).
Damit die Checkboxen funktionieren, muss jeder Datensatz eine eindeutige ID
erzeugen können. Dazu gibt es bei jeder Datasource die Information, welche
Spalten das sind. Aktuell gibt es dazu schon "keys". Problem hier ist nur,
dass da noch die Downtime-IDs mitkommen, die man hier nicht braucht. Diese
sollte man irgendwie weglassen können.  Die Checkbox bekommt also also
HTML-Variablennamen die jeweilige ID - irgendwie enkodiert so dass es
keine Probleme mit Sonderzeichen gibt.  Wenn die Schleife der Kommandos
ausgeführt wird, muss ich jeweils noch kontrollieren, ob der Datensatz,
um den es gerade geht, auch gecheckt ist (oder Checkboxen generell aus
sind). Wenn Kein Datensatz gewählt wurde, spucke ich eine Fehlermeldung aus.

Checkboxen(2): [1] Neuer Reiter mit drei Zuständen: keine Checkboxen
alle gecheckt, alle leer. Der Zustand wird als viewoption persistent und
auch bei der View als Parameter eingebaut, so dass der Admin einen Default
vorgeben kann. Evtl. kann die View auch festlegen, ob überhaupt ein Reiter
kommt. [2] Beim Anzeigen eines Layouts muss diese eine extra TD malen,
welches eine Checkbox enthält (wenn der Reiter sichtbar ist).  Der Name der
Checkbox muss über eine eindeutige Zeilen-ID bestimmt sein.  und man muss -
nach der Tabelle - ein eine Javascript-Funktion ausgeben, die das Umschalten
der über das Tab regelt - alle an / alle aus, umschalten.  Das muss dann
per Ajax auch die View-Option umstellen und die Optik des Tabs ändern. Wenn
man auf unsichtbar schaltet, müssen alle Boxen auf gecheckt gesetzt werden,
damit das Kommando auch wirklich auf allen ausgeführt wird. [3] Wenn man
jetzt auf ein Kommando klickt, muss ich bei jedem Datensatz wieder die ID
berechnen. Dann schauen, ob es eine Check-Variable gibt. Falls ja, muss
diese auf "on" stehen, damit das Kommando ausgeführt wird.  Wenn keines
gewält ist, soll ein Hinweis kommen (gelb).

Views: Man könnte eine ASCII-View bauen, die kein HTML ausspuckt, sondern
simples ASCII. Frage ist dabei, was man mit den Paintern macht. Hier müsste
man die sichtbare Information aus den HTML-Tags rausholen, also eine Art
HTML->ASCII Filter programmieren. Auch die Überschrift ist dann betroffen
und die Fusszeile. Analog dazu könnte man sich eine Ausgabe als CSV oder
XML vorstellen. Hintergrund ist eine Art Webservice.

Precompile und Konfigerzeugung: Das könnte auf mehrere CPUs skalieren.
Dazu starten man konfigurierbar viele Threads. Bei Precompiled macht einfach
jeder der N Threads ein N'tel der Hosts. Bei der Konfigerzeugung müsste
man die Konfig zunächst im Speicher erzeugen und dann die Ergebnisse
der 8 Threads am Ende zusammenbauen. Davor muss aber die Umstellung der
Konfigerzeugung gemacht werden, bei der immer ein Host und seine Services
gemeinsam ausgespuckt werden.

Idee zur Umbenennung von Konfig-Parametern: Wenn z.B. eine Konfigvariable
hirn hieß und jetzt sepp heißen soll, dann könnte man dies Deklarieren
in check_mk.py:
renamed_config_vars = [
  ( "hirn", "depp", 1127002033 )
]
Jetzt könnte man vor dem Einlesen der Konfig die Ist-Werte speichern,
und zwar mit Objektreferenzen, um festzustellen, ob der Benutzer
hier etwas geändert hat. Alernativ schaut man nach globals:
# Nach dem Einlesen der Konfig:
for old, new, deadline in renamed_config_vars:
  if old in globals():
      sys.stderr.write("WARNING: Config var '%s' has been renamed to '%s'. Please fix this until %s" % (old, new, strftime(deadline...)))
      if time.time() < deadline:
          eval("%s = '%r'" % (new, eval(old)))
      else:
          sys.stderr.write("You had enough time to fix this. Sorry.\n")
          sys.exit(1)
Auf diese Art funktioniert erstmal alles weiter. Trotzdem wird die Variable
irgendwann planmäßig abgeschaltet.

View options für Painter: Ein Painter hat eine Liste von Painter-Viewoptions.
Dazu gibt es ein dict: painter_view_options["pnpsource"] = { 
( "PNP Timerange", "1", [("0":"4 hours"), ("1", "24 hours"), ... ] )
Vor dem Anzeigen des Layouts ermittle ich alle benötigten View-Options.
Analog zu refersh mache ich Persisitierung und HTML-Variablen-Auswertung
und komme zu einem Ergebnis. Das speichere ich dann in view_option["pnpsource"].
Dies kann der Painter einfach abfragen. Einsatz: PNP-Zeitraum, Darstellung
von Zeitstempeln (Delta/Absolute/Mixed).

Multisite: Wenn man bei einer View einen Filter ausfüllt (user), dann
soll irgendwo ein Icon anzeigen, dass das Resultat gefiltert ist.

Multisite: Hover: Wenn man über einen Painter geht, könnte man eine
Hover aufmachen, der einen weiteren Painter anzeigt. Das macht man
über eine Auswahlbox analog zu der "Link to".

Vorschlag von Bastian: Bei den Views könnte man den Datenbereich (Tabelle)
per Ajax refreshen und müsste nicht die ganze Seite neu aufbauen. Damit
wird ein Bildschirmflimmern vermieden.

Vorschlag(2) von Bastian: 
    Der Agent spuckt zwei neue Zeilen aus:
    StartTime: 127006756
    ..
    ..
    ..
    End Time: 127007654
    
    Check_MK prüft daraus:
    1. Ausführzeit des Agenten
    2. Alter der Daten (z.B. für asynchrone Agenten)
    
    In der main.mk muss man jetzt konfigurieren können, was
    passiert, wenn die Zeiten zu hoch sind. Z.B.:
    
    agent_execution_time_default_levels = (10, 30)
    agent_execution_time_levels = [ 
      # ORACLE-Rechner brauchen länger
      ( (30, 50), ["oracle"], ALL_HOSTS ),
    ]
    
    agent_freshness_default_levels = (5, 10)
    agent_freshness_levels = [
      ( ( 60, 90), [ "async" ], ALL_HOSTS ),
    ]
    
    Das ganze wird geprüft vom Hauptcheck. Wenn bei der
    freshness der kritische Wert zieht, werden die
    Resultate verworfen und die Checks nicht ausgeführt
    
Livestatus soll im Logfile eine Warnung ausgeben, wenn die
environment_macros aktiviert sind.

FreeBSD Agent:
  Auf der Homepage sollte ein Hinweis platziert werden, dass es einen neuen
  Agent gibt. Dieser basiert zwar auf dem Linux Agenten, gibt momentan aber
  wesentlich weniger Daten aus, da die Sektionen noch nicht portiert sind.
  
  Dazu wird eine Beschreibung benötigt, wie dieser zu installieren ist.
  1. inetd installieren
  2. /etc/services hinzufügen:
  check_mk_agent  6556/tcp   # Check_MK's agent
  3. /etc/inetd.conf hinzufügen:
  check_mk_agent  stream  tcp     nowait  root    /usr/bin/check_mk_agent check_mk_agent
  4. inetd neu starten
  -> Eventuell noch ein anderer Pfad für den Agent (?). Gibt es da andere Vorgaben
     auf FreeBSD Systemen?
  
  Die Sektionen/Checks ps und postfix_mailq sind jetzt schon kompatibel.

Idee: Bei SNMP-Checks gibt es manchmal Daten, die sich dynamisch nicht ändern
(z.B. Interfacenamen, etc.). Man könnte diese Daten cachen, so dass sie nicht
jedes mal geholt werden, sondern z.B. nur alle 10 Minuten.

IDEE: Prefetching agent: Der agent soll die Daten schon berechnen kurz bevor
sie abgefragt werden. Das ganze läuft so: Zunächst ermittelt der Agent,
wie lange die Datenberechnung im Schnitt dauert (z.B. über schleichenden
Mittelwert), sagen wir 5 Sekunden. Über den gleichen Wert ermittelt er, wie
oft er abgefragt wird, sagen wir alle 60 Sekunden. Wenn der Agent kontaktiert
wird, kann er dann einen günstigen Zeitpunkt ermitteln, zu dem er beginnt,
die Daten aufzubereiten.  Im Beispiel ist das spätestens 55 Sekunden nach
der letzten Anfrage, mit etwas Puffer kann man z.B. 5 Sekunden früher
beginnen. Das ganze schützt man über ein Lock, so dass wenn das Prefetch
noch nicht begonnen hat oder nicht fertig ist, wenn eine Anfrage kommt,
der Anfrager warten muss. Ergebnis: Auf eine Anfrage kommt im Optimalfall
immer *sofort* ein Ergebnis. Außerdem kann das Berechnen mit nice laufen.
Das könnte man auch in den Windows-Agenten integrieren und so die Probleme
beheben, die auftreten, wenn das System unter hoher Last steht.

Options --list-tags, welche alle Tags ausgibt.

Livestatus: Spalte bei Services und Hosts, die das ausgeführte Kommando
(mit expandierten Makros!) enthaelt.

Multisite: Spalte, die das Kommando (die Befehlszeile) ausgibt.

Multisite: Eine konfigurierbare URL für die Startseite (also
alternativ zum rechten Startframe.

Multisite: Man soll über eine Variable die URL für die rechte
Seite mitgeben können. So kann man direkt auf eine Unterseite
verlinken. Evtl. das sogar abrufbar über ein Icon :-)

Multisite: icon_image von Nagios sollte angezeigt werden

Livestatus: Informationen ueber Eskalationen ausgeben (eigene Tabelle
        oder Anreicherung von contacts, hosts, services)

IPv6-Support in Check_MK:
def lookup_ipaddress(hostname):
    if fake_dns:
        return fake_dns
    elif simulation_mode:
        return "127.0.0.1"
    else:
        ipa = ipaddresses.get(hostname)
        if ipa:
            return ipa
        else:
            #return socket.gethostbyname(hostname)
            #gets only the first address of the first interface...
            for res in socket.getaddrinfo(hostname, None):
                family, socktype, proto, canonname, sockaddr = res
                return sockaddr[0]
Ausserdem kommt check_icmp damit nicht klar. Hier muss dann auf
check_ping ausgewichen werden. 

Wenn eine IP-Adresse nicht aufgelöst werden kann, sollte stattdessen
eine (konfigurierbare) Dummyadresse verwendet werden. Sonst
scheitert check_mk -O, wenn ein DNS-Eintrag verschwindet.

Livestatus: neben custom_variable_names und custom_variable_values
waere noch custom_variables huebsch, welches beides kombiniert.

Disk IO read/write: Zu einem Check zusammenfassen. Einen gemeinsamen
Graphen mit dem Windows-Check erstellen (wo ein Graph eh fehlt).
 
Multisite: Quicksearch evtl. case-insensitive machen?

if/if64: Irgendwie eine Konfigurationsart finden, welche den
Linkstatus nicht prüft bzw. deswegen nicht kritisch wird.
Das kann man evtl. sogar damit kombinieren, dass man alle
ports monitort. Könnte reichen, wenn das Inventur-Konfigurationen
sind.

Livestatus: StatsGroupBy: mehrere Spalten erlauben

Multisite: Die TOP-25 Alerts: Welche Dinge hosts/services
hatten in einem Zeitraum die meisten Alerts. Das geht
mit log und StatsGroupBy: host_name service_description

Multisite: Filter, der Hosts zeigt, die entweder selbst
Summary hosts sind oder keinen haben.

Multisite: Könnte man nicht Aggregationen in Views einbauen.
Man würde dann in der View Regeln definieren, nach denen
Services und Hosts aggregiert werden können. Dazu müsste man 
in den View-Editor einen neuen Abschnitt einbauen. Ist das
nicht ähnlich wie Gruppieren? Allerdings wäre es dann gut,
wenn man die Aggregationen irgendwo separat editieren kann
und in der View nur noch drauf verweisen. Sonst muss
man soviel Copy&Paste zwischen den Views machen...

Idee: Checks, die eigentlich keine Perfdaten liefern, könnten
über eine Konfiguration künstlich perfdaten bekommen, ala
status=0, status=1 etc. Das könnte man über eine Regel
konfigurierbar machen:
fake_perfdata = [ ... ]

Idee: Inventurcheck könnte gleich die Checkergebnisse berechnen

local-Struktur: Hier gibt es scheinbar einen Bug in mod_python.
index.py -> execfile(plugins/pages/...) -> import config
Jetzt bekommt man eine neue Instanz von config. In dem importierten
Modul kann man das wie folgt reparieren:
from mod_python import importer, apache
config = importer.import_module("config", 
    path = ["/omd/sites/webconf/share/check_mk/web/htdocs"])
Das kann aber doch keine Lösung sein. Andererseits braucht man
dies nur wenn wenn in config was ändert oder bei livestatus
(wegen der persistenten Verbindungen). Sonst kanns einem egal
sein, wenn man ein neues Modul bekommt.

Windows-Agent: VB-Scripts automatisch mit cscript ausführen.

Snapins: die letzten 10 Notifikationen, die letzten 10 Alerts
(evtl. umschaltbar per Tabs)

Acknowledgements: Ankreuzung, ob persistent oder nicht


