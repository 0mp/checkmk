#!/usr/bin/python
# encoding: utf-8

import socket, os, time, sys, getopt, signal, thread, pprint, re, select, subprocess, stat, pickle, uuid
from pwd import getpwnam
from grp import getgrnam


VERSION="1.2.2b1"
#   .--Helper functions----------------------------------------------------.
#   |                  _   _      _                                        |
#   |                 | | | | ___| |_ __   ___ _ __ ___                    |
#   |                 | |_| |/ _ \ | '_ \ / _ \ '__/ __|                   |
#   |                 |  _  |  __/ | |_) |  __/ |  \__ \                   |
#   |                 |_| |_|\___|_| .__/ \___|_|  |___/                   |
#   |                              |_|                                     |
#   +----------------------------------------------------------------------+
#   |  Various helper functions                                            |
#   '----------------------------------------------------------------------'
def format_exception():
    import StringIO, traceback
    txt = StringIO.StringIO()
    t, v, tb = sys.exc_info()
    traceback.print_exception(t, v, tb, None, txt)
    return txt.getvalue()

def bail_out(reason):
    log("FATAL ERROR: %s" % reason)
    sys.exit(1)

def make_parentdirs(file_path):
    dir_path = os.path.dirname(file_path)
    if not os.path.exists(dir_path):
        os.makedirs(dir_path)

def process_exists(pid):
    try:
        os.kill(pid, 0)
        return True
    except:
        return False

def open_logfile():
    global g_logfile
    g_logfile = file(g_logfile_path, "a")

def log(text):
    if type(text) == unicode:
        text = text.encode("utf-8")
    try:
        g_logfile.write('[%.6f] %s\n' % (time.time(), text))
       # g_logfile.flush()
    except:
        sys.stderr.write("%s\n" % text)

#   .--Daemonize-----------------------------------------------------------.
#   |          ____                                   _                    |
#   |         |  _ \  __ _  ___ _ __ ___   ___  _ __ (_)_______            |
#   |         | | | |/ _` |/ _ \ '_ ` _ \ / _ \| '_ \| |_  / _ \           |
#   |         | |_| | (_| |  __/ | | | | | (_) | | | | |/ /  __/           |
#   |         |____/ \__,_|\___|_| |_| |_|\___/|_| |_|_/___\___|           |
#   |                                                                      |
#   +----------------------------------------------------------------------+
#   |  Code for daemonizing                                                |
#   '----------------------------------------------------------------------'

def daemonize(user=0, group=0):
    # do the UNIX double-fork magic, see Stevens' "Advanced
    # Programming in the UNIX Environment" for details (ISBN 0201563177)
    try:
        pid = os.fork()
        if pid > 0:
            # exit first parent
            sys.exit(0)
    except OSError, e:
        sys.stderr.write("Fork failed (#1): %d (%s)\n" % (e.errno, e.strerror))
        sys.exit(1)

    # decouple from parent environment
    # chdir -> don't prevent unmounting...
    os.chdir("/")

    # Create new process group with the process as leader
    os.setsid()

    # Set user/group depending on params
    if group:
        os.setregid(getgrnam(group)[2], getgrnam(group)[2])
    if user:
        os.setreuid(getpwnam(user)[2], getpwnam(user)[2])

    # do second fork
    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError, e:
        sys.stderr.write("Fork failed (#2): %d (%s)\n" % (e.errno, e.strerror))
        sys.exit(1)

    sys.stdout.flush()
    sys.stderr.flush()

    si = os.open("/dev/null", os.O_RDONLY)
    so = os.open("/dev/null", os.O_WRONLY)
    os.dup2(si, 0)
    os.dup2(so, 1)
    os.dup2(so, 2)
    os.close(si)
    os.close(so)

    log("Daemonized with PID %d." % os.getpid())

def open_socket():
    if opt_verbose:
        log("open tcp socket port .." )

    global tcp_socket
    tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    # TODO: configurable port
    tcp_socket.bind(("0.0.0.0", g_config["notification_daemon_listen_port"]))
    tcp_socket.listen(200)

def close_socket():
    global tcp_socket
    if tcp_socket:
        tcp_socket.close()

def load_configuration():
    global g_config, g_config_last_reload
    g_config = {
        "notification_daemon_listen_port": 6555,
        "notification_deferred_retention_time": 180,
        "notification_forward_to": "",
    }

    list_of_files = reduce(lambda a,b: a+b,
         [ [ "%s/%s" % (d, f) for f in fs if f.endswith(".mk")]
             for d, sb, fs in os.walk(g_config_dir + "/mknotifyd.d" ) ], [])

    list_of_files.sort()
    for path in list_of_files:
        execfile(path, g_config, g_config)

    g_last_config_reload = time.time()

def usage():
    sys.stdout.write("""Usage: mknotifyd [OPTIONS]

   -v, --verbose        Enable verbose output
   -g, --foreground     Do not daemonize, run in foreground
   -s, --single         Single shot, exit after one cycle

""")
    if os.getenv("OMD_ROOT"):
        sys.stdout.write("""You are running OMD, which is generally a good idea. 
The following defaults are set:

  Config dir:  %(g_config_dir)s
  Var dir:     %(g_var_dir)s
  PID file:    %(g_pid_file)s
  Log file:    %(g_logfile_path)s

""" % globals())


def process_directory(dirname, files_older_than = None):
    global deferred_dir
    now = time.time()
    print "process dir " , dirname
    for root, dirs, files in os.walk(dirname):
        for spoolfile in files:
            spoolfile_process_result = -1
            # Check spoolfile type
            # Spoolfiles with the key forward are handled locally
            spoolfilename = "%s/%s" % (root, spoolfile)
            file_age = now - os.stat(spoolfilename)[8]
            
            if file_age < files_older_than:
                log("File age %d" % file_age)
                continue                
            
            content = eval(file(spoolfilename).read())
            if content.get("forward"):
                response_text = ""
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(10)
                    host, port = content.get("forward").split(':',1)
                    del content["forward"]
                    log("Forward notification to %s %s" % (host, port))
                    sock.connect((host, int(port)))
                    sock.send(pickle.dumps(content))
                    # Wait for OK response  
                    while True:
                        readable = select.select([sock], [], [], 1)[0]
                        data = None
                        try:
                           chunk = sock.recv(8192)
                           response_text += chunk
                           if not chunk:
                               break
                        except:
                            break # Error while reading
                except Exception, e:
                    # Connection problems
                    log(format_exception())
                spoolfile_process_result = response_text != "OK" and 1 or 0
            else:
                spoolfile_process_result = os.system("cmk --notify spoolfile %s" % spoolfilename)

            log("process result <%d> of file %s " % (spoolfile_process_result, spoolfilename))
            if spoolfile_process_result == 1:
                # Moving logfile to deferred and retry later 
                deferred_file = "%s/%s" % (deferred_dir, spoolfile)
                os.rename(spoolfilename, deferred_file)
                file(deferred_file, "a").close()
            else: 
                os.remove(spoolfilename)


def run_notifyd():
    global reopen_sockets, tcp_socket, deferred_dir
    spool_dir = "%s/notify/spool" % g_var_dir
    deferred_dir = "%s/notify/deferred" % g_var_dir

    if not os.path.exists(spool_dir):
        os.makedirs(spool_dir)

    if not os.path.exists(deferred_dir):
        os.makedirs(deferred_dir)

    handled_connections = 0

    while True:
        if reopen_sockets:
            reopen_sockets = False
            close_socket()
            open_socket()
    
        
#        process_directory(spool_dir)
#        process_directory(deferred_dir, g_config["notification_deferred_retention_time"])

        # Socket handling, wird spaeter eigener Prozess?
        info = select.select([tcp_socket], [], [], 0.2)
        readable = info[0]

        for s in readable:
            log("handled connections %d" % handled_connections)
            handled_connections = handled_connections + 1

            client_socket, addr_info = s.accept()
            data = client_socket.recv(8192)
            # log("Received notification from %s" % pprint.pformat(addr_info))
            try:
                content = pickle.loads(data)
                if "context" in content:  
                    log("have context.. " )
                    context = content["context"]
                    if not context["CONTACTNAME"]:
                        log("ERROR processing client data")
                        client_socket.send("ERROR")
                    else:
                        contact_dir = "%s/%s" % (spool_dir, context["CONTACTNAME"])
                        if not os.path.exists(contact_dir):
                            os.makedirs(contact_dir)
                        spoolfile = "%s/%0.2f_%s" % (contact_dir, time.time(), uuid.uuid1())
                        file(spoolfile,"w").write("%r" % content)
                        #file(spoolfile,"w").write(pprint.pformat(content))
                        log("client data processed - sending OK")
                        client_socket.send("OK")
            except Exception, e:
                log("ERROR processing client data")
                print e, format_exception()
                client_socket.send("ERROR")
            client_socket.close()

        time.sleep(0.002)
        if opt_single_cycle:
            return

#.
#   .--Main----------------------------------------------------------------.
#   |                        __  __       _                                |
#   |                       |  \/  | __ _(_)_ __                           |
#   |                       | |\/| |/ _` | | '_ \                          |
#   |                       | |  | | (_| | | | | |                         |
#   |                       |_|  |_|\__,_|_|_| |_|                         |
#   |                                                                      |
#   +----------------------------------------------------------------------+
#   |  Main entry and option parsing                                       |
#   '----------------------------------------------------------------------'

os.unsetenv("LANG")
opt_verbose      = False
opt_foreground   = False
opt_single_cycle = False

# Set default values for options
omd_root = os.getenv("OMD_ROOT")
if omd_root:
    g_config_dir      = omd_root + "/etc/check_mk"
    g_var_dir         = omd_root + "/var/check_mk"
    g_pid_file        = omd_root + "/tmp/run/mknotifyd/pid"
    g_logfile_path    = omd_root + "/var/log/mknotifyd.log"
else:
    g_config_dir      = "/etc/check_mk"
    g_var_dir         = "/var/check_mk"
    g_pid_file        = "/var/run/mknotifyd.pid"
    g_logfile_path    = "/var/log/mknotifyd.log"

tcp_socket = None
reopen_sockets = False

short_options = "hVvgs"
long_options = [ "help", "version", "verbose", "foreground", "single" ]

try:
    opts, args = getopt.getopt(sys.argv[1:], short_options, long_options)

    # first parse modifers
    for o, a in opts:
        if o in [ '-v', '--verbose' ]:
            opt_verbose += 1
        elif o in [ '-g', '--foreground' ]:
            opt_foreground = True
        elif o in [ '-s', '--single' ]:
            opt_single_cycle = True

    # now handle action options
    for o, a in opts:
        if o in [ '-h', '--help' ]:
            usage()
            sys.exit(0)
        elif o in [ '-V', '--version' ]:
            sys.stdout.write("mknotifyd version %s\n" % VERSION)
            sys.exit(0)

    # Prepare logging if running in daemon mode
    if not opt_foreground:
        open_logfile()
    log("-" * 65)
    log("mknotifyd version %s starting" % VERSION)

    load_configuration()

    if os.path.exists(g_pid_file):
        old_pid = int(file(g_pid_file).read())
        if process_exists(old_pid):
            bail_out("Old PID file %s still existing and mknotifyd still running with PID %d." % 
                (g_pid_file, old_pid))
        os.remove(g_pid_file)
        log("Removed orphaned PID file %s (process %d not running anymore)." % (g_pid_file, old_pid))

    # Make sure paths exist
    make_parentdirs(g_logfile_path)

    # Open sockets
    open_socket()

    # Daemonize
    if not opt_foreground:
        make_parentdirs(g_pid_file)
        daemonize()

    # Create PID file
    file(g_pid_file, "w").write("%d\n" % os.getpid())

    # Install signal hander
#    signal.signal(2,  signal_handler)  # INT

    # Now let's go...
    run_notifyd()
    
    # Close sockets
    close_socket()
    
    # We reach this point, if the server has been killed by
    # a signal or hitting Ctrl-C (in foreground mode)

    os.remove(g_pid_file)
    log("Successfully shut down.")
    sys.exit(0)

except Exception, e:
    bail_out(e)






